@load functions
@load smtp

# NOTES:
# * Events:
#   mime_all_headers loops and could potentially be a bad idea. More prone to DoS as well.
#   mime_all_data is probably also a bad idea.  Especially for large files.
#   mime_entity_data seems very similar to mime_all_data and is not chunked as the similarity to the http_entity_data would imply.
#   mime_next_entity is never generated by the core or policy scripts.
#   mime_segment_data should probaly be renamed to mime_entity_data
#   mime_one_header should probably be renamed to mime_header
#   no clue what mime_event is for.
#   mime_content_hash gives a non printable hash value.
##
# * Core analyzer:
#   #ifdef DEBUG_BRO used instead of #ifdef DEBUG
#   Possibly worthwhile removing MD5 sum calculation and mime type inspection.  It's done in this script now.
#   mime_end_entity is is generated generated multiple times erroneousy in some cases.

module MIME;

#redef enum Notice::Type += {};
redef enum Log::ID += { MIME };

export {
	# Let's assume for now that nothing that is transferring files using 
	# MIME attachments is multiplexing for simplicity's sake.
	#   We can make the assumption that one connection == one file (at a time)
	type Log: record {
		## This is the timestamp of when the MIME content transfer began.
		ts:               time;
		id:               conn_id;
		filename:         string &optional;
		on_disk_filename: string &optional;
		mime_type:        string &optional;
		mime_desc:        string &optional;
		content_len:      count &default=0;
		md5_hash:         string &optional;
	};
	
	type Info: record {
		log:           Log;
		
		## Track the number of MIME encoded files transferred during this session.
		level:         count &default=0;
		## Track how deep into the MIME encoded file.
		data_offset:   count &default=0;
		## Store the file handle here for the currently extracting file.
		file_handle:   file &optional;
		## Optionally write the file to disk.  Must be set prior to first data chunk being seen in an event.
		write_file:    bool &default=F;
		## Optionally calculate the file's MD5 sum.  Must be set prior to the first data chunk being see in an event.
		calc_md5:      bool &default=F;
	};
	
	## The default setting for extracting files to disk.
	const default_write_file = F &redef;
	
	## The default setting for calculating MD5 sums on files transferred.
	const default_calc_md5 = F &redef;
	
	#global mime_header_handler: table[string] of mime_header_handler_func;
	global active_sessions: table[conn_id] of Info;
	
	global log_mime: event(rec: Log);
}

event bro_init()
	{
	Log::create_stream(MIME, [$columns=Log, $ev=log_mime]);
	}


function new_log(c: connection): Log
	{
	local id = c$id;
	return [$ts=network_time(), $id=id];
	}
	
function new_mime_session(c: connection)
	{
	local info: Info = [$log=new_log(c), $write_file=default_write_file,
	                    $calc_md5=default_calc_md5];
	active_sessions[c$id] = info;
	}

function get_session(c: connection): Info
	{
	local id = c$id;
	
	if ( id !in active_sessions )
		new_mime_session(c);

	return active_sessions[id];
	}


# event mime_one_header(c: connection, h: mime_header_rec)
#	{
#	local session = get_session(c);
#	mime_message(session, "header",
#			fmt("%s: \"%s\"", h$name, h$value));
#	mime_header_handler[h$name](session, h$name, h$value);
#	}

event mime_begin_entity(c: connection) &priority=1
	{
	local session = get_session(c);

	++session$level;
	session$data_offset = 0;
	}

event mime_segment_data(c: connection, length: count, data: string) &priority=1
	{
	local session = get_session(c);

	if ( session$data_offset == 0 )
		{
		session$log$mime_type = identify_data(data, T);
		session$log$mime_desc = identify_data(data, F);
		
		if ( session$write_file )
			{
			local fname = fmt("%s-%d.mimefile", id_string(c$id), session$level);
			session$file_handle = open(fname);
			session$log$on_disk_filename = fname;
			}
			
		if ( session$calc_md5 )
			{
			md5_hash_init(c$id);
			}
		}
	
	session$data_offset = session$data_offset + length;
	# Update the log value too.
	session$log$content_len = session$data_offset;
	
	if ( session$calc_md5 )
		md5_hash_update(c$id, data);

	if ( session$write_file && session?$file_handle )
		write_file(session$file_handle, data);
	}
	
event mime_end_entity(c: connection) &priority=-1
	{
	local session = get_session(c);
	
@ifdef ( SMTP::active_sessions )
	# TODO: this needs to be done smarter.
	if ( SMTP::active_sessions[c$id]$log?$files )
		{
		for ( fl in SMTP::active_sessions[c$id]$log$files )
			session$log$filename = fl;
		}
@endif
	
	if ( session$calc_md5 )
		session$log$md5_hash = md5_hash_finish(c$id);
	if ( session?$file_handle )
		close(session$file_handle);
	
	Log::write(MIME, session$log);
	
	session$write_file=default_write_file;
	session$calc_md5=default_calc_md5;
	session$log = new_log(c);
	
	if ( session$level > 0 )
		--session$level;
	}

event connection_state_remove(c: connection) &priority=-1
	{
	local id = c$id;

	if ( id in active_sessions )
		delete active_sessions[id];
	}

#event mime_event(c: connection, event_type: string, detail: string)
#	{
#	print event_type;
#	print detail;
#	local session = get_session(c);
#	mime_message(session, "event", fmt("%s: %s", event_type, detail));
#	}
