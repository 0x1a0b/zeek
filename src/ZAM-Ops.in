# Templates used to generate virtual functions, opcodes, and evaluation
# code for compiled code.

########## Unary Ops ##########

assign-op Assign
type X
eval @$2

unary-expr-op Clone
op-type X
set-type $1
set-expr $2
eval auto v = frame[z.v2].ToVal(z.e->Type().get())->Clone();
eval AssignV1(BuildVal(v, z.t));

unary-expr-op Size
no-const
op-type i u d A N S T V *
type-selector 2
set-type $1
set-expr $2
#
eval_i $$.uint_val = $1 < 0 ? -$1 : $1
#
eval_u $$.uint_val = $1
#
eval_d $$.double_val = $1 < 0 ? -$1 : $1
#
eval_A $$.uint_val = $1->AsAddr().GetFamily() == IPv4 ? 32 : 128
#
eval_N $$.double_val = pow(2.0, double(128 - $1->AsSubNet().LengthIPv6()))
#
eval_S $$.uint_val = $1->Len()
#
eval_T $$.uint_val = $1->Size()
#
eval_V $$.uint_val = $1->Size()
#
eval auto v = frame[z.v2].ToVal(z.e->Type().get())->SizeVal(); $$ = BuildVal(v, z.t);

unary-expr-op Not
op-type I
eval ! $1

unary-expr-op Complement
op-type U
eval ~ $1

unary-expr-op Positive
op-type I D
vector
eval $1

unary-expr-op Negate
op-type I D
vector
eval -$1

op IncrI
op1-read-write
type V
eval ++frame[z.v1].int_val

op IncrU
op1-read-write
type V
eval ++frame[z.v1].uint_val

op DecrI
op1-read-write
type V
eval --frame[z.v1].int_val

op DecrU
op1-read-write
type V
eval --frame[z.v1].uint_val

unary-op AppendTo
# Note, even though it feels like appending both reads and modifies
# its first operand, for our purposes it just reads it (to get the
# aggregate), and then modifies its *content* but not the operand's
# value itself.
op1-read
set-type $2
eval auto copy = CopyVal($1)
eval auto& vv = frame[z.v1].vector_val->ModVec()
eval vv.push_back(copy)

unary-expr-op Cast
op-type X
set-type $1
set-expr $2
eval const char* error;
eval auto rhs = frame[z.v2].ToVal(z.e->Type().get()).get();
eval auto res = cast_value(rhs, z.t, error);
eval if ( error ) ZAM_run_time_error(z.stmt, error);
eval else AssignV1(BuildVal(res, z.t));

# Cast an "any" type to the given type.  Only needed for type-based swith
# statements.
internal-op Cast-Any
type VV
eval const char* error
eval auto res = cast_value(frame[z.v2].any_val, z.t, error)
eval if ( error ) ZAM_run_time_error(z.stmt, error)
eval else AssignV1(BuildVal(res, z.t));

direct-unary-op Is Is

internal-op Is
type VV
eval auto rhs = frame[z.v2].ToVal(z.e->Type().get()).get()
eval frame[z.v1].int_val = can_cast_value_to_type(rhs, z.t)

########## Binary Ops ##########

binary-expr-op Add
op-type I U D S
vector
eval $1 + $2
eval_S vector<const BroString*> strings
eval_S strings.push_back($1->AsString())
eval_S strings.push_back($2->AsString())
eval_S auto res = new StringVal(concatenate(strings))
eval_S Unref($$)
eval_S $$ = res

binary-expr-op Sub
op-type I U D T
vector
eval $1 - $2
#
eval_T auto v = $1->Clone()
eval_T Unref($$)
eval_T $$ = v->AsTableVal()
eval_T $2->RemoveFrom($$)

binary-expr-op Times
op-type I U D
vector
eval $1 * $2

binary-expr-op Divide
op-type I U D
set-expr $1
vector
#
eval-pre if ( $2 == 0 ) { ZAM_run_time_error(z.stmt, "division by zero"); break; }
eval $1 / $2
#
eval-mixed A I auto mask = static_cast<uint32_t>($2)
eval-mixed A I auto a = $1->AsAddr()
eval-mixed A I if ( a.GetFamily() == IPv4 && mask > 32 ) z.e->RuntimeError(fmt("bad IPv4 subnet prefix length: %" PRIu32, mask))
eval-mixed A I if ( a.GetFamily() == IPv6 && mask > 128 ) z.e->RuntimeError(fmt("bad IPv6 subnet prefix length: %" PRIu32, mask))
eval-mixed A I auto v = make_intrusive<SubNetVal>(a, mask)
eval-mixed A I Unref(frame[z.v1].subnet_val)
eval-mixed A I frame[z.v1].subnet_val = v.release()
eval-mixed A I /* Note, $$ is ignored but mentioned here so templator backs off */

binary-expr-op Mod
op-type I U
vector
eval-pre if ( $2 == 0 ) { ZAM_run_time_error(z.stmt, "modulo by zero"); break; }
eval $1 % $2

binary-expr-op And-And
op-type I
vector
eval $1 && $2

binary-expr-op Or-Or
op-type I
vector
eval $1 || $2

binary-expr-op And
op-type U P T
vector
eval $1 & $2
#
eval_P auto p = new PatternVal(RE_Matcher_conjunction($1->AsPattern(), $2->AsPattern()))
eval_P Unref($$)
eval_P $$ = p
#
eval_T $$ = $1->Intersect($2)

binary-expr-op Or
op-type U P T
vector
eval $1 | $2
#
eval_P auto p = new PatternVal(RE_Matcher_disjunction($1->AsPattern(), $2->AsPattern()))
eval_P Unref($$)
eval_P $$ = p
#
eval_T auto v = $1->Clone()
eval_T Unref($$)
eval_T $$ = v->AsTableVal()
eval_T (void) $2->AddTo($$, false, false)

binary-expr-op Xor
op-type U
vector
eval $1 ^ $2

########## Relationals ##########

rel-expr-op LT
op-type I U D S T A
vector
eval $1 < $2
eval_S Bstr_cmp($1->AsString(), $2->AsString()) < 0
eval_T $1->IsSubsetOf($2) && $1->Size() < $2->Size()
eval_A $1->AsAddr() < $2->AsAddr()

rel-expr-op LE
op-type I U D S T A
vector
eval $1 <= $2
eval_S Bstr_cmp($1->AsString(), $2->AsString()) <= 0
eval_T $1->IsSubsetOf($2)
eval_A $1->AsAddr() < $2->AsAddr() || $1->AsAddr() == $2->AsAddr()

rel-expr-op EQ
op-type I U D S T A N
vector
eval $1 == $2
eval_S Bstr_cmp($1->AsString(), $2->AsString()) == 0
eval_T $1->EqualTo($2)
eval_A $1->AsAddr() == $2->AsAddr()
eval_N $1->AsSubNet() == $2->AsSubNet()
eval-mixed P S $1->AsPattern()->MatchExactly($2->AsString())

rel-expr-op NE
op-type I U D S T A N
vector
eval $1 != $2
eval_S Bstr_cmp($1->AsString(), $2->AsString()) != 0
eval_T ! $1->EqualTo($2)
eval_A $1->AsAddr() != $2->AsAddr()
eval_N $1->AsSubNet() != $2->AsSubNet()
eval-mixed P S ! $1->AsPattern()->MatchExactly($2->AsString())

# Note, canonicalization means that GE and GT shouldn't occur
# for Sets (type T).
rel-expr-op GE
op-type I U D S A
vector
eval $1 >= $2
eval_S Bstr_cmp($1->AsString(), $2->AsString()) >= 0
eval_A ! ($1->AsAddr() < $2->AsAddr())

rel-expr-op GT
op-type I U D S A
vector
eval $1 > $2
eval_S Bstr_cmp($1->AsString(), $2->AsString()) > 0
eval_A ! ($1->AsAddr() < $2->AsAddr()) && $1->AsAddr() != $2->AsAddr()

########## Nonuniform Expressions ##########

assign-op Field
type R
field-op
eval auto rv = $2.record_val->RawFields()
eval auto v = rv->Lookup(z.v3, ZAM_error)
eval if ( ZAM_error ) z.e->RuntimeError("field value missing")
eval else @v

expr-op Has-Field
type Ri
eval frame[z.v1].int_val = (frame[z.v2].record_val->RawFields()->HasField(z.v3))

expr-op In
type VVV
custom-method return CompileInExpr($*);
no-eval

expr-op In
type VCV
custom-method return CompileInExpr($*);
no-eval

expr-op In
type VVC
custom-method return CompileInExpr($*);
no-eval

internal-op P-In-S
type VVV
eval frame[z.v1].int_val = frame[z.v2].re_val->AsPattern()->MatchAnywhere(frame[z.v3].string_val->AsString()) != 0

internal-op P-In-S
type VCV
eval frame[z.v1].int_val = z.c.re_val->AsPattern()->MatchAnywhere(frame[z.v2].string_val->AsString()) != 0

internal-op P-In-S
type VVC
eval frame[z.v1].int_val = frame[z.v2].re_val->AsPattern()->MatchAnywhere(z.c.string_val->AsString()) != 0

internal-binary-op S-In-S
op-accessor string_val
op-type I
eval auto sc = reinterpret_cast<const unsigned char*>(op1->CheckString())
eval auto cmp = strstr_n(op2->Len(), op2->Bytes(), op1->Len(), sc)
eval $$ = cmp != -1

internal-binary-op A-In-S
op1-accessor addr_val
op2-accessor subnet_val
op-type I
eval $$ = op2->Contains(op1->AsAddr())


# Handled differently because of the unusual middle argument.
op L-In-T
type VLV
custom-method return CompileInExpr(n1, l, n2);
no-eval

op L-In-T
type VLC
custom-method return CompileInExpr(n, l, c);
no-eval

op L-In-Vec
type VLV
custom-method return CompileInExpr(n1, l, n2);
no-eval

op L-In-Vec
type VLC
custom-method return CompileInExpr(n, l, c);
no-eval


internal-op Val-Is-In-Table
type VVV
# No set-type as these are internal ops.
eval auto op1 = frame[z.v2].ToVal(z.t)
eval frame[z.v1].int_val = frame[z.v3].table_val->Lookup(op1.get()) != nullptr

internal-op Const-Is-In-Table
type VCV
eval auto op1 = z.c.ToVal(z.t)
eval frame[z.v1].int_val = frame[z.v2].table_val->Lookup(op1.get()) != nullptr

internal-op List-Is-In-Table
type VVV
eval auto op1 = frame[z.v3].list_val
eval frame[z.v1].int_val = frame[z.v2].table_val->Lookup(op1) != nullptr
eval Unref(op1)

internal-op List-Is-In-Table
type VVC
eval auto op1 = frame[z.v2].list_val
eval frame[z.v1].int_val = z.c.table_val->Lookup(op1) != nullptr
eval Unref(op1)

internal-op Index-Is-In-Vector
type VVV
eval auto op1 = frame[z.v3].list_val
eval auto op2 = frame[z.v2].vector_val->ToVectorVal(z.t)
eval frame[z.v1].int_val = op2->Lookup(op1) != nullptr
eval Unref(op1)

internal-op Index-Is-In-Vector
type VVC
eval auto op1 = frame[z.v2].list_val
eval auto op2 = z.c.vector_val->ToVectorVal(z.t)
eval frame[z.v1].int_val = op2->Lookup(op1) != nullptr
eval Unref(op1)

expr-op Cond
type VVVV
set-type $3
eval AssignV1(frame[z.v2].int_val ? CopyVal(frame[z.v3]) : CopyVal(frame[z.v4]))

expr-op Cond
type VVVC
set-type $3
eval AssignV1(frame[z.v2].int_val ? CopyVal(frame[z.v3]) : CopyVal(z.c))

expr-op Cond
type VVCV
set-type $3
eval AssignV1(frame[z.v2].int_val ? CopyVal(z.c) : CopyVal(frame[z.v3]))

# Our statement structure doesn't accommodate two constants, so for
# the singular case of a V ? C1 : C2 conditional, we split it into
# two operations, V ? C1 and !V ? C2.
op CondC1
type VVC
set-type $1
eval if ( frame[z.v2].int_val ) AssignV1(CopyVal(z.c))

op CondC2
set-type $1
type VVC
eval if ( ! frame[z.v2].int_val ) AssignV1(CopyVal(z.c))

########## Index Expressions ##########

op IndexVecBoolSelect
type VVV
set-type $1
eval if ( frame[z.v2].vector_val->Size() != frame[z.v3].vector_val->Size() ) {
eval	ZAM_run_time_error(z.stmt, "size mismatch, boolean index and vector")
eval	break; }
eval auto vt = z.t->AsVectorType()
eval auto v2 = frame[z.v2].vector_val->ToVectorVal(vt)
eval auto v3 = frame[z.v3].vector_val->ToVectorVal(vt)
eval auto v = vector_bool_select(vt, v2.get(), v3.get())
eval Unref(frame[z.v1].vector_val)
eval frame[z.v1].vector_val = to_ZAM_vector(v)

op IndexVecIntSelect
type VVV
set-type $1
eval auto vt = z.t->AsVectorType()
eval auto v2 = frame[z.v2].vector_val->ToVectorVal(vt)
eval auto v3 = frame[z.v3].vector_val->ToVectorVal(vt)
eval auto v = vector_int_select(vt, v2.get(), v3.get())
eval Unref(frame[z.v1].vector_val)
eval frame[z.v1].vector_val = to_ZAM_vector(v)

op Index
type VVL
custom-method return CompileIndex(n1, n2, l);

internal-op Index-Vec
type VVV
eval auto vv = frame[z.v2].vector_val
eval auto& vec = vv->ConstVec()
eval auto ind = frame[z.v3].uint_val
eval if ( ind >= vv->Size() ) ZAM_run_time_error(z.stmt, "no such index")
eval AssignV1(CopyVal(vec[ind]))

internal-op Index-VecC
type VVV
eval auto vv = frame[z.v2].vector_val
eval auto& vec = vv->ConstVec()
eval auto ind = z.v3
eval if ( ind >= vv->Size() ) ZAM_run_time_error(z.stmt, "no such index")
eval AssignV1(CopyVal(vec[ind]))

internal-op Index-Vec
type VVL
eval auto yt = z.t->AsVectorType()->YieldType()
eval auto vec = frame[z.v2].vector_val->ToVectorVal(z.t)
eval auto lv = frame[z.v3].list_val
eval auto v = vec->Lookup(lv)
eval Unref(lv)
eval AssignV1T(BuildVal(v, yt), yt)

internal-op Index-Vec-Slice
type VVL
eval auto vt = z.t->AsVectorType()
eval auto vec = frame[z.v2].vector_val->ToVectorVal(z.t)
eval auto lv = frame[z.v3].list_val
eval auto v = vector_index(vt, vec.get(), lv)
eval Unref(lv)
eval Unref(frame[z.v1].vector_val)
eval frame[z.v1].vector_val = to_ZAM_vector(v)

internal-op Table-Index
type VVV
eval auto v2 = frame[z.v3].list_val
eval auto v = frame[z.v2].table_val->Lookup(v2)
eval Unref(v2)
eval if ( ! v ) ZAM_run_time_error(z.stmt, "no such index")
eval AssignV1(BuildVal(v, z.t))

# This version is for a variable v3.
internal-op Index-String
type VVV
eval auto str = frame[z.v2].string_val->AsString()
eval auto len = str->Len()
eval auto idx = frame[z.v3].int_val
eval if ( idx < 0 ) idx += len
eval auto v = str->GetSubstring(idx, 1)
eval Unref(frame[z.v1].string_val)
eval frame[z.v1].string_val = new StringVal(v ? v : new BroString(""))

# This version is for a constant v3.
internal-op Index-StringC
type VVV
eval auto str = frame[z.v2].string_val->AsString()
eval auto len = str->Len()
eval auto idx = z.v3
eval if ( idx < 0 ) idx += len
eval auto v = str->GetSubstring(idx, 1)
eval Unref(frame[z.v1].string_val)
eval frame[z.v1].string_val = new StringVal(v ? v : new BroString(""))

internal-op Index-String-Slice
type VVL
eval auto str = frame[z.v2].string_val->AsString()
eval auto lv = frame[z.v3].list_val
eval auto slice = index_string_slice(str, lv)
eval Unref(lv)
eval Unref(frame[z.v1].string_val)
eval frame[z.v1].string_val = new StringVal(slice)

op AnyIndex
type VVi
set-type $1
eval auto lv = frame[z.v2].any_val->AsRecordVal()->RawFields()
eval auto elem = lv->NthField(z.v3)
eval if ( ! elem ) reporter->InternalError("failure to load \"any\" element");
eval if ( CheckAnyType(elem->Type(), z.t, z.stmt) ) {
eval	AssignV1(BuildVal(elem, z.t))
eval } else ZAM_error = true


########## Constructors ##########

# Table construction requires atypical evaluation of list elements
# using information from their expression specifics.  We punt those
# back to the interpreter.
direct-unary-op Table-Constructor InterpretExpr

# In for a penny, in for a pound.  For now we just do all of them that
# way, even though with some elbow grease we could do the others directly.
direct-unary-op Set-Constructor InterpretExpr
direct-unary-op Record-Constructor InterpretExpr
direct-unary-op Vector-Constructor InterpretExpr

########## Coercions ##########

direct-unary-op Arith-Coerce ArithCoerce

internal-op Coerce-UI
type VV
eval auto v = frame[z.v2].int_val
eval if ( v < 0 ) { ZAM_run_time_error(z.stmt, "underflow converting int to count"); break; }
eval frame[z.v1].uint_val = bro_uint_t(v)

internal-op Coerce-UI-Vec
type VV
eval Unref(frame[z.v1].vector_val)
eval frame[z.v1].vector_val = vec_coerce_UI(frame[z.v2].vector_val)

internal-op Coerce-UD
type VV
eval auto v = frame[z.v2].double_val
eval if ( v < 0.0 ) { ZAM_run_time_error(z.stmt, "underflow converting double to count"); break; }
eval if ( v > UINT64_MAX ) { ZAM_run_time_error(z.stmt, "overflow converting double to count"); break; }
eval frame[z.v1].uint_val = bro_uint_t(v)

internal-op Coerce-UD-Vec
type VV
eval Unref(frame[z.v1].vector_val)
eval frame[z.v1].vector_val = vec_coerce_UD(frame[z.v2].vector_val)

internal-op Coerce-IU
type VV
eval auto v = frame[z.v2].uint_val
eval if ( v > INT64_MAX ) { ZAM_run_time_error(z.stmt, "overflow converting count to int"); break; }
eval frame[z.v1].int_val = bro_int_t(v)

internal-op Coerce-IU-Vec
type VV
eval Unref(frame[z.v1].vector_val)
eval frame[z.v1].vector_val = vec_coerce_IU(frame[z.v2].vector_val)

internal-op Coerce-ID
type VV
eval auto v = frame[z.v2].double_val
eval if ( v < static_cast<double>(INT64_MIN) ) { ZAM_run_time_error(z.stmt, "underflow converting double to int"); break; }
eval if ( v > static_cast<double>(INT64_MAX) ) { ZAM_run_time_error(z.stmt, "overflow converting double to int"); break; }
eval frame[z.v1].int_val = bro_int_t(v)

internal-op Coerce-ID-Vec
type VV
eval Unref(frame[z.v1].vector_val)
eval frame[z.v1].vector_val = vec_coerce_ID(frame[z.v2].vector_val)

internal-op Coerce-DI
type VV
eval frame[z.v1].double_val = double(frame[z.v2].int_val)

internal-op Coerce-DI-Vec
type VV
eval Unref(frame[z.v1].vector_val)
eval frame[z.v1].vector_val = vec_coerce_DI(frame[z.v2].vector_val)

internal-op Coerce-DU
type VV
eval frame[z.v1].double_val = double(frame[z.v2].uint_val)

internal-op Coerce-DU-Vec
type VV
eval Unref(frame[z.v1].vector_val)
eval frame[z.v1].vector_val = vec_coerce_DU(frame[z.v2].vector_val)

direct-unary-op Record-Coerce RecordCoerce

internal-op Record-Coerce
type VVV
eval auto rt = z.t->AsRecordType()
eval auto v = frame[z.v2].record_val
eval auto map = z.int_ptr
eval auto map_size = z.v3
eval auto to_r = coerce_to_record(rt, v, map, map_size)
eval Unref(frame[z.v1].record_val)
eval frame[z.v1].record_val = to_r.release()

direct-unary-op Table-Coerce TableCoerce

internal-op Table-Coerce
type VV
eval auto tv = frame[z.v2].table_val
eval if ( tv->Size() > 0 ) { ZAM_run_time_error(z.stmt, "coercion of non-empty table/set"); break; }
eval IntrusivePtr<TableType> tt = {NewRef{}, z.t->AsTableType()}
eval IntrusivePtr<Attributes> attrs = {NewRef{}, tv->Attrs()}
eval auto t = make_intrusive<TableVal>(tt, attrs)
eval Unref(frame[z.v1].table_val)
eval frame[z.v1].table_val = t.release()

direct-unary-op Vector-Coerce VectorCoerce

internal-op Vector-Coerce
type VV
eval if ( frame[z.v2].vector_val->Size() > 0 ) { ZAM_run_time_error(z.stmt, "coercion of non-empty vector"); break; }
eval auto t = z.t->Ref()->AsVectorType();
eval auto vv_p = make_intrusive<VectorVal>(t)
eval Unref(frame[z.v1].vector_val)
eval frame[z.v1].vector_val = to_ZAM_vector(vv_p)

unary-expr-op To-Any-Coerce
set-type $2
eval ZAMValUnion($1.ToVal(z.t), base_type_no_ref(TYPE_ANY))

unary-expr-op From-Any-Coerce
set-type $1
eval ZAMValUnion({NewRef{}, $1.any_val}, z.t)


########## Aggregate Assignments ##########

op Vector-Elem-Assign
op1-read
type VVV
eval auto ind = frame[z.v2].uint_val
eval auto vv = frame[z.v1].vector_val
eval vv->SetGeneralYieldType(z.t)
eval vv->SetElement(ind, frame[z.v3])

op Vector-Elem-Assign-Any
op1-read
type VVV
eval auto ind = frame[z.v2].uint_val
eval auto vv = frame[z.v1].vector_val
eval vv->SetGeneralYieldType(z.t)
eval auto any_v = frame[z.v3].any_val
eval auto any_z = ZAMValUnion({NewRef{}, any_v}, any_v->Type())
eval vv->SetElement(ind, any_z)

op Vector-Elem-Assign
op1-read
type VVC
eval auto ind = frame[z.v2].uint_val
eval auto vv = frame[z.v1].vector_val
eval vv->SetGeneralYieldType(z.t)
eval vv->SetElement(ind, z.c)

# These versions are used when the constant is the index, not the new value.
op Vector-Elem-Assign
op1-read
type VVi
eval auto vv = frame[z.v1].vector_val
eval vv->SetGeneralYieldType(z.t)
eval vv->SetElement(z.v3, frame[z.v2])

op Vector-Elem-Assign-Any
op1-read
type VVi
eval auto vv = frame[z.v1].vector_val
eval vv->SetGeneralYieldType(z.t)
eval auto any_v = frame[z.v2].any_val
eval auto any_z = ZAMValUnion({NewRef{}, any_v}, any_v->Type())
eval vv->SetElement(z.v3, any_z)


assign-op Field-LHS-Assign
op1-read
type F
eval @$2
eval frame[z.v1].record_val->RawFields()->Assign($3, v)

########## General Statements ##########

op Schedule
type ViHL
op1-read
custom-method return CompileSchedule(n, nullptr, i, h, l);
eval double dt = frame[z.v1].double_val
eval if ( z.v2 ) dt += network_time
eval auto handler = EventHandlerPtr(z.event_handler)
eval auto args = frame[z.v3].vvec
eval auto timer = new ScheduleTimer(z.event_handler, std::move(*args), dt)
eval delete frame[z.v3].vvec
eval timer_mgr->Add(timer)

op Schedule
type CiHL
custom-method return CompileSchedule(nullptr, c, i, h, l);
eval double dt = z.c.double_val
eval if ( z.v1 ) dt += network_time
eval auto hp = EventHandlerPtr(z.event_handler)
eval auto args = frame[z.v2].vvec
eval auto timer = new ScheduleTimer(z.event_handler, std::move(*args), dt)
eval delete frame[z.v2].vvec
eval timer_mgr->Add(timer)


op Event
type HL
custom-method return CompileEvent(h, l);
eval mgr.Enqueue(z.event_handler, std::move(*frame[z.v1].vvec))
eval delete frame[z.v1].vvec


op Return
type X
eval ret_u = nullptr
eval pc = end_pc; continue

op Return
op1-read
type V
set-type $1
eval ret_u = &frame[z.v1]
eval ret_type = z.t
eval pc = end_pc; continue

op Return
type C
eval ret_u = &z.c
eval ret_type = z.t
eval pc = end_pc; continue


# Branch on the value of v1 using switch table v2, with default branch to v3
internal-op SwitchI
type VVV
op1-read
eval auto v = frame[z.v1].int_val
eval auto t = int_cases[z.v2]
eval if ( t.find(v) == t.end() ) pc = z.v3
eval else pc = t[v]->inst_num
eval continue

internal-op SwitchU
op1-read
type VVV
eval auto v = frame[z.v1].uint_val
eval auto t = uint_cases[z.v2]
eval if ( t.find(v) == t.end() ) pc = z.v3
eval else pc = t[v]->inst_num
eval continue

internal-op SwitchD
op1-read
type VVV
eval auto v = frame[z.v1].double_val
eval auto t = double_cases[z.v2]
eval if ( t.find(v) == t.end() ) pc = z.v3
eval else pc = t[v]->inst_num
eval continue

internal-op SwitchS
op1-read
type VVV
eval auto vs = frame[z.v1].string_val->AsString()->Render()
eval std::string v(vs)
eval auto t = str_cases[z.v2]
eval if ( t.find(v) == t.end() ) pc = z.v3
eval else pc = t[v]->inst_num
eval delete[] vs
eval continue

internal-op SwitchA
op1-read
type VVV
eval auto v = frame[z.v1].addr_val->AsAddr().AsString()
eval auto t = str_cases[z.v2]
eval if ( t.find(v) == t.end() ) pc = z.v3
eval else pc = t[v]->inst_num
eval continue

internal-op SwitchN
op1-read
type VVV
eval auto v = frame[z.v1].subnet_val->AsSubNet().AsString()
eval auto t = str_cases[z.v2]
eval if ( t.find(v) == t.end() ) pc = z.v3
eval else pc = t[v]->inst_num
eval continue


internal-op Branch-If-Not-Type
op1-read
type VV
eval auto v = frame[z.v1].any_val
eval if ( ! can_cast_value_to_type(v, z.t) ) { pc = z.v2; continue; }


internal-op Init-Table-Loop
type VVC
eval auto ii = z.c.iter_info
eval ii->tv = frame[z.v2].table_val
eval ii->loop_vals = ii->tv->AsTable()
eval ii->c = ii->loop_vals->InitForIteration()
eval ii->value_var_type = z.t
eval frame[z.v1].iter_info = ii

internal-op Next-Table-Iter
# v1 = iteration info
# v2 = branch target if loop done
type VV
eval HashKey* k
eval auto ii = frame[z.v1].iter_info
eval TableEntryVal* current_tev = ii->loop_vals->NextEntry(k, ii->c)
eval if ( ! current_tev ) { pc = z.v2; continue; }
eval auto ind_lv = ii->tv->RecoverIndex(k);
eval delete k
eval for ( int i = 0; i < ind_lv->Length(); i++ ) {
eval	IntrusivePtr<Val> ind_lv_p = {NewRef{}, ind_lv->Index(i)}
eval	auto t = ii->loop_var_types[i]
eval	auto& var = frame[ii->loop_vars[i]]
eval	if ( IsManagedType(t) ) DeleteManagedType(var, t)
eval	var = BuildVal(ind_lv_p, ii->loop_var_types[i])
eval }

internal-op Next-Table-Iter-Val-Var
# v1 = slot of the "ValueVar"
# v2 = iteration info
# v3 = branch target if loop done
type VVV
eval HashKey* k
eval auto ii = frame[z.v2].iter_info
eval TableEntryVal* current_tev = ii->loop_vals->NextEntry(k, ii->c)
eval if ( ! current_tev ) { pc = z.v3; continue; }
eval auto ind_lv = ii->tv->RecoverIndex(k);
eval delete k
eval IntrusivePtr<Val> tev_p = {NewRef{}, current_tev->Value()}
eval auto val_var_t = ii->value_var_type
eval if ( IsManagedType(val_var_t) ) DeleteManagedType(frame[z.v1], val_var_t)
eval frame[z.v1] = BuildVal(tev_p, val_var_t)
eval for ( int i = 0; i < ind_lv->Length(); i++ ) {
eval	IntrusivePtr<Val> ind_lv_p = {NewRef{}, ind_lv->Index(i)}
eval	auto ind = ii->loop_vars[i]
eval	auto loop_var_t = ii->loop_var_types[i]
eval	if ( IsManagedType(loop_var_t) ) DeleteManagedType(frame[ind], loop_var_t)
eval	frame[ind] = BuildVal(ind_lv_p, loop_var_t)
eval }

internal-op Init-Vector-Loop
type VV
eval auto ii = z.c.iter_info
eval ii->vv = {NewRef{}, frame[z.v2].vector_val}
eval ii->n = ii->vv->Size()
eval ii->iter = 0
eval frame[z.v1].iter_info = ii

# v1 = iteration variable
# v2 = iteration info
internal-op Next-Vector-Iter
type VVV
eval auto ii = frame[z.v2].iter_info
eval if ( ii->iter >= ii->n ) { pc = z.v3; continue; }
eval auto& vv = ii->vv->ConstVec()
eval if ( vv[ii->iter].IsNil(ii->yield_type) ) { ++ii->iter; --pc; break; }
eval frame[z.v1].uint_val = ii->iter
eval ++ii->iter

internal-op Init-String-Loop
type VV
eval auto ii = z.c.iter_info
eval ii->s = frame[z.v2].string_val->AsString()
eval ii->iter = 0
eval ii->n = ii->s->Len()
eval frame[z.v1].iter_info = ii

# v1 = iteration variable
# v2 = iteration info
internal-op Next-String-Iter
type VVV
eval auto ii = frame[z.v2].iter_info
eval auto sval = ii->s
eval if ( ii->iter >= ii->n ) { pc = z.v3; continue; }
eval auto bytes = (const char*) sval->Bytes() + ii->iter
eval auto sv = new StringVal(1, bytes)
eval Unref(frame[z.v1].string_val)
eval frame[z.v1].string_val = sv
eval ++ii->iter

internal-op End-Loop
type V
eval auto ii = frame[z.v1].iter_info
eval if ( ii->c ) ii->loop_vals->StopIteration(ii->c)
eval ii->c = nullptr
eval ii->vv = nullptr


op When
op1-read
type VVVV
eval auto when_body = new ResumptionAM(this, z.v2)
eval auto timeout_body = new ResumptionAM(this, z.v3)
eval new trigger::Trigger(z.non_const_e, when_body, timeout_body, frame[z.v1].double_val, f, z.v4, z.stmt->GetLocationInfo())

op When
type VVVC
eval auto when_body = new ResumptionAM(this, z.v2)
eval auto timeout_body = new ResumptionAM(this, z.v3)
eval new trigger::Trigger(z.non_const_e, when_body, timeout_body, z.c.double_val, f, z.v4, z.stmt->GetLocationInfo())

op When
type VV
eval auto when_body = new ResumptionAM(this, z.v2)
eval new trigger::Trigger(z.non_const_e, when_body, nullptr, -1.0, f, z.v1, z.stmt->GetLocationInfo())

op CheckAnyLen
op1-read
type Vi
eval auto v = frame[z.v1].list_val
eval if ( v->Vals()->length() != z.v2 ) ZAM_run_time_error(z.stmt, "mismatch in list lengths")
eval Unref(v)

op Print
op1-read
type O
eval auto vvec = frame[z.v1].vvec
eval do_print(*vvec)
eval delete vvec
method-pre int reg = v->n; delete v

op Print1
op1-read
type V
set-type $1
eval std::vector<IntrusivePtr<Val>> vals
eval vals.push_back(frame[z.v1].ToVal(z.t))
eval do_print(vals)

op Print1
op1-read
type C
set-type $1
eval std::vector<IntrusivePtr<Val>> vals
eval vals.push_back(z.c.ToVal(z.t))
eval do_print(vals)


internal-op If-Else
op1-read
type VV
eval if ( ! frame[z.v1].int_val ) { pc = z.v2; continue; }

internal-op If
op1-read
type VV
eval if ( ! frame[z.v1].int_val ) { pc = z.v2; continue; }

internal-op If-Not
op1-read
type VV
eval if ( frame[z.v1].int_val ) { pc = z.v2; continue; }


op AddStmt
op1-read
type VO
eval auto vvec = frame[z.v2].vvec
eval auto lval = ValVecToListVal(vvec, vvec->size())
eval frame[z.v1].table_val->Assign(lval, nullptr)
eval delete lval
method-pre int reg = v->n; delete v


op DelTable
op1-read
type VO
eval auto vvec = frame[z.v2].vvec
eval auto lval = ValVecToListVal(vvec, vvec->size())
eval frame[z.v1].table_val->Delete(lval)
eval delete lval
method-pre int reg = v->n; delete v

op DelField
op1-read
type Vi
eval frame[z.v1].record_val->RawFields()->DeleteField(z.v2)


internal-op Init-Record
type V
eval auto r = new RecordVal(z.t->AsRecordType())
eval Unref(frame[z.v1].record_val)
eval frame[z.v1].record_val = r

# v1 is the frame element being initialized
# v2 is its slot in the interpreted frame
internal-op Init-Vector
type VV
eval auto vt = z.t->AsVectorType()
eval auto yt = vt->YieldType()
eval auto vec = make_intrusive<VectorVal>(vt)
eval Unref(frame[z.v1].vector_val)
eval frame[z.v1].vector_val = to_ZAM_vector(vec)

internal-op Init-Table
type V
eval IntrusivePtr<TableType> tt = {NewRef{}, z.t->AsTableType()}
eval IntrusivePtr<Attributes> attrs = {NewRef{}, z.attrs}
eval auto t = new TableVal(tt, attrs)
eval Unref(frame[z.v1].table_val)
eval frame[z.v1].table_val = t


########################################
# Internal
########################################

op Sync-Globals
type X
eval for ( auto i = 1; i <= num_globals; ++i ) {
eval	if ( global_state[i] == GS_DIRTY ) {
eval		auto id = frame_denizens[i]
eval		auto t = id->Type()
eval		auto v = frame[i].ToVal(t)
eval		id->SetVal(v)
eval	}
eval	global_state[i] = GS_UNLOADED
eval }

op Dirty-Global
op1-internal
type V
eval global_state[z.v1] = GS_DIRTY

# These two are only needed for type-based switch statements.  Could think
# about replacing them using CoerceFromAnyExpr.
op Assign-Any
type VV
set-type $2
eval auto v = frame[z.v2].ToVal(z.t)
eval frame[z.v1].any_val = v.release()

op Assign-Any
type VC
set-type $2
eval auto v = z.c.ToVal(z.t)
eval frame[z.v1].any_val = v.release()

# Lazy way to assign without having to track the specific type of
# a constant.
internal-op Assign-Const
type VC
eval AssignV1(BuildVal(z.c.ToVal(z.t), z.t))

internal-op Load-Val
type VV
eval auto v = f->NthElement(z.v2)
eval if ( ! v ) reporter->InternalError("failure to load frame element")
eval IntrusivePtr<Val> v_p = {NewRef{}, v}
eval AssignV1(BuildVal(v_p, z.t))

internal-op Load-Any-Val
type VV
eval IntrusivePtr<Val> v = {NewRef{}, f->NthElement(z.v2)}
eval frame[z.v1].any_val = v.release()

internal-op Load-Global
op1-internal
type VC
eval if ( global_state[z.v1] == GS_UNLOADED ) {
eval	IntrusivePtr<Val> v = {NewRef{}, z.c.id_val->ID_Val()}
eval	AssignV1(BuildVal(v, z.t))
eval	global_state[z.v1] = GS_CLEAN
eval }

internal-op Load-Any-Global
op1-internal
type VC
eval if ( global_state[z.v1] == GS_UNLOADED ) {
eval	IntrusivePtr<Val> v = {NewRef{}, z.c.id_val->ID_Val()}
eval	frame[z.v1].any_val = v.release()
eval	global_state[z.v1] = GS_CLEAN
eval }

internal-op Store-Val
op1-read
type VV
eval auto val = frame[z.v1].ToVal(z.t)
eval f->SetElement(z.v2, val.release())

### This now should work as just an ordinary Store-Val.
internal-op Store-Any-Val
op1-read
type VV
eval auto v = frame[z.v1].any_val->Ref()
eval f->SetElement(z.v2, v)

internal-op Copy-To
type VC
set-type $2
eval AssignV1(CopyVal(z.c))

# Initializes a new value vector.  We now do this dynamically, but at same
# point we could switch it to a static vector since we'll only have one of
# these at at time.
# 
# v1 is where to store the vector, v2 is its size (which we don't presently
# use).

internal-op Create-Val-Vec
type V
eval frame[z.v1].vvec = new val_vec

# Appends v2 to the vector pointed to by v1.
internal-op Set-Val-Vec
type VV
eval auto v = frame[z.v2].ToVal(z.t)
eval frame[z.v1].vvec->push_back(v)

# Appends c to the vector pointed to by v1.
internal-op Set-Val-Vec
type VC
eval auto c = z.c.ToVal(z.t)
eval frame[z.v1].vvec->push_back(c)

# Turns the vector at v2 (with v3 items) into a list_val at v1.  Deletes
# the original.
internal-op Transform-Val-Vec-To-List-Val
type VVV
eval frame[z.v1].list_val = ValVecToListVal(frame[z.v2].vvec, z.v3)


# Interprets the statement's expression as a stand-alone statement.
internal-op Interpret-Expr
type X
eval (void) z.e->Eval(f) /* this could invoke us recursively */

# Interprets the statement's expression and assigns the result to v1.
internal-op Interpret-Expr
type V
eval auto v = z.e->Eval(f) /* this could invoke us recursively */
eval AssignV1(BuildVal(v, z.t))

# Interprets the statement's expression and assigns the result to v1,
# where v1 is an "any" type.
internal-op Interpret-Expr-Any
type V
eval frame[z.v1].any_val = z.e->Eval(f).release()


internal-op GoTo
type V
eval pc = z.v1
eval continue

internal-op Hook-Break
type X
eval flow = FLOW_BREAK
eval pc = end_pc
eval continue


# Make sure that the given vector-of-any is either empty or in fact
# has the expected concrete internal type.
internal-op Check-Any-Vec
op1-read
type V
eval auto any_vec = frame[z.v1].vector_val
eval auto at = any_vec->GeneralYieldType()
eval if ( ! at ) break
eval if ( at->Tag() == TYPE_ANY && any_vec->ConstVec().size() > 0 ) reporter->InternalError("non-concrete vector-of-any")
eval if ( ! CheckAnyType(at, z.t, z.stmt) ) ZAM_error = true

# Transform the given vector-of-any to a concrete internal type.
internal-op Transform-Any-Vec
op1-read-write
type V
eval auto any_vec = frame[z.v1].vector_val
eval auto at = any_vec->GeneralYieldType()
eval if ( ! at || at->Tag() == TYPE_ANY ) {
eval	if ( at && any_vec->ConstVec().size() > 0 ) reporter->InternalError("concretizing non-empty vector-of-any")
eval	any_vec->SetGeneralYieldType(z.t)
eval }

# Transform the given vector-of-any (v1) to be compatible with having one of
# its elements assigned to the dynamic type of the "any" value (v2).
internal-op Transform-Any-Vec2
op1-read-write
type VV
eval auto vt = frame[z.v2].any_val->Type()
eval auto any_vec = frame[z.v1].vector_val
eval auto at = any_vec->GeneralYieldType()
eval if ( ! at || at->Tag() == TYPE_ANY ) {
eval	if ( at && any_vec->ConstVec().size() > 0 ) reporter->InternalError("concretizing non-empty vector-of-any")
eval	any_vec->SetGeneralYieldType(vt)
eval }


########################################
# Built-in Functions
########################################

internal-op Sub-Bytes
type VVVV
eval auto sv = ZAM_sub_bytes(frame[z.v2].string_val, frame[z.v3].uint_val, frame[z.v4].int_val)
eval Unref(frame[z.v1].string_val)
eval frame[z.v1].string_val = sv

internal-op Sub-Bytes
type VVVi
eval auto sv = ZAM_sub_bytes(frame[z.v2].string_val, frame[z.v3].uint_val, z.v4)
eval Unref(frame[z.v1].string_val)
eval frame[z.v1].string_val = sv

internal-op Sub-Bytes
type VViV
eval auto sv = ZAM_sub_bytes(frame[z.v2].string_val, bro_uint_t(z.v4), frame[z.v3].int_val)
eval Unref(frame[z.v1].string_val)
eval frame[z.v1].string_val = sv

internal-op Sub-Bytes
type VVii
eval auto sv = ZAM_sub_bytes(frame[z.v2].string_val, bro_uint_t(z.v3), z.v4)
eval Unref(frame[z.v1].string_val)
eval frame[z.v1].string_val = sv

internal-op Sub-Bytes
type VVVC
eval auto sv = ZAM_sub_bytes(z.c.string_val, frame[z.v2].uint_val, frame[z.v3].int_val)
eval Unref(frame[z.v1].string_val)
eval frame[z.v1].string_val = sv

internal-op Sub-Bytes
type VViC
eval auto sv = ZAM_sub_bytes(z.c.string_val, frame[z.v2].uint_val, z.v3)
eval Unref(frame[z.v1].string_val)
eval frame[z.v1].string_val = sv

internal-op Sub-Bytes
type ViVC
eval auto sv = ZAM_sub_bytes(z.c.string_val, bro_uint_t(z.v3), frame[z.v2].int_val)
eval Unref(frame[z.v1].string_val)
eval frame[z.v1].string_val = sv

internal-op Sub-Bytes
type ViiC
eval auto sv = ZAM_sub_bytes(z.c.string_val, bro_uint_t(z.v2), z.v3)
eval Unref(frame[z.v1].string_val)
eval frame[z.v1].string_val = sv

internal-op To-Lower
type VV
eval auto sv = ZAM_to_lower(frame[z.v2].string_val)
eval Unref(frame[z.v1].string_val)
eval frame[z.v1].string_val = sv

# A ZAM version of Log::__write.  In calls to it, the first argument
# is generally a constant (enum) *if we inlined*, but otherwise a
# parameter, so we support both VVV ad VVC.
#
# It's actually the case that the return value is pretty much always ignored.
#
# Could speed things up further by modifying the Write method to just
# take the raw enum value, as it appears that that's all that's ever
# actually used.
internal-op Log-Write
type VVV
eval auto id = frame[z.v2].ToVal(log_ID_enum_type)
eval auto columns = frame[z.v3].ToVal(z.t)
eval bool result = log_mgr->Write(id->AsEnumVal(), columns->AsRecordVal())
eval frame[z.v1].int_val = result

internal-op Log-Write
type VVC
eval auto id = z.c.ToVal(log_ID_enum_type)
eval auto columns = frame[z.v2].ToVal(z.t)
eval bool result = log_mgr->Write(id->AsEnumVal(), columns->AsRecordVal())
eval frame[z.v1].int_val = result

internal-op Broker-Flush-Logs
type V
eval frame[z.v1].uint_val = broker_mgr->FlushLogBuffers()

internal-op Get-Port-Transport-Proto
type VV
eval auto mask = frame[z.v2].uint_val & PORT_SPACE_MASK
eval auto v = 0; /* TRANPORT_UNKNOWN */
eval if ( mask == TCP_PORT_MASK ) v = 1
eval else if ( mask == UDP_PORT_MASK ) v = 2
eval else if ( mask == ICMP_PORT_MASK ) v = 3
eval frame[z.v1].uint_val = v

internal-op Reading-Live-Traffic
type V
eval frame[z.v1].int_val = reading_live

internal-op Reading-Traces
type V
eval frame[z.v1].int_val = reading_traces
