# Templates used to generate virtual functions, opcodes, and evaluation
# code for compiled code.

########## Unary Ops ##########

unary-expr-op Assign
eval $1

unary-expr-op Clone
set-type $1
eval AS_ValUnion($1.ToVal(s.t)->Clone().release(), s.t)

unary-expr-op Size
set-type $1
eval AS_ValUnion($1.ToVal(s.t)->SizeVal().release(), s.t)

unary-expr-op Not
op-type I
eval ! $1

unary-expr-op Complement
op-type U
eval ~ $1

unary-expr-op Positive
op-type I D
vector
eval $1

unary-expr-op Negate
op-type I D
vector
eval -$1

########## Binary Ops ##########

binary-expr-op Add
op-type I U D S
vector
eval $1 + $2
eval_S vector<const BroString*> strings
eval_S strings.push_back($1)
eval_S strings.push_back($2)
eval_S $$ = concatenate(strings)

binary-expr-op Sub
op-type I U D T
vector
eval $1 - $2
eval_T $$ = $1->Clone()->AsTableVal()
eval_T $2->RemoveFrom($$)

binary-expr-op Times
op-type I U D
vector
eval $1 * $2

binary-expr-op Divide
op-type I U D
vector
eval-pre if ( $2 == 0 ) run_time_error("division by zero")
eval $1 / $2

binary-expr-op Mod
op-type I U
vector
eval-pre if ( $2 == 0 ) run_time_error("modulo by zero")
eval $1 % $2

binary-expr-op And
op-type U P T
vector
eval $1 & $2
eval_P $$ = RE_Matcher_conjunction($1, $2)
eval_T $$ = $1->Intersect($2)

binary-expr-op Or
op-type U P T
vector
eval $1 | $2
eval_P $$ = RE_Matcher_disjunction($1, $2)
eval_T $$ = $1->Clone()->AsTableVal()
eval_T (void) $2->AddTo($$, false, false)

binary-expr-op Xor
op-type U
vector
eval $1 ^ $2

########## Relationals ##########

rel-expr-op LT
op-type I U D S T A
vector
eval $1 < $2
eval_S $$ = Bstr_cmp($1, $2) < 0
eval_T $$ = $1->IsSubsetOf($2) && $1->Size() < $2->Size()
eval_A $$ = $1 < $2

rel-expr-op LE
op-type I U D S T A
vector
eval $1 <= $2
eval_S $$ = Bstr_cmp($1, $2) <= 0
eval_T $$ = $1->IsSubsetOf($2)
eval_A $$ = $1 < $2 || $1 == $2

rel-expr-op EQ
op-type I U D S T A N
vector
eval $1 == $2
eval_S $$ = Bstr_cmp($1, $2) == 0
eval_T $$ = $1->EqualTo($2)
eval_A $$ = $1 == $2
eval_N $$ = *$1 == *$2
eval-mixed P S $$ = $1->MatchExactly($2)

rel-expr-op NE
op-type I U D S T A N
vector
eval $1 != $2
eval_S $$ = Bstr_cmp($1, $2) != 0
eval_T $$ = ! $1->EqualTo($2)
eval_A $$ = $1 != $2
eval_N $$ = *$1 != *$2
eval-mixed P S $$ = ! $1->MatchExactly($2)

# Note, canonicalization means that GE and GT shouldn't occur
# for Sets (type T).
rel-expr-op GE
op-type I U D S A
vector
eval $1 >= $2
eval_S $$ = Bstr_cmp($1, $2) >= 0
eval_A $$ = ! ($1 < $2)

rel-expr-op GT
op-type I U D S A
vector
eval $1 > $2
eval_S $$ = Bstr_cmp($1, $2) > 0
eval_A $$ = ! ($1 < $2) && $1 != $2

########## Nonuniform Expressions ##########

expr-op Field
type R
eval_R frame[s.v1] = AS_ValUnion(frame[s.v2].record_val->Lookup(s.v3), s.t)

########################################

unary-op AppendTo
eval auto vv = frame[s.v1].vector_val
eval vv->Assign(vv->Size(), $1.ToVal(s.t))

########################################

op Return
type X
eval ret_u = nullptr
eval loop = false
method-pre	SyncGlobals()

op Return
type V
eval ret_u = &frame[s.v1]
eval ret_type = s.t
eval loop = false
method-pre	SyncGlobals()

op Return
type C
eval ret_u = &s.c
eval ret_type = s.t
eval loop = false
method-pre	SyncGlobals()

########################################

op Print
type O
eval auto vvec = frame[s.v1].vvec
eval do_print(*vvec)
eval delete vvec
method-pre int reg = v->n; delete v

########################################
# Internal
########################################

# Initializes a new value vector.  We now do this dynamically, but at same
# point we could switch it to a static vector since we'll only have one of
# these at at time.
# 
# v1 is where to store the vector, v2 is its size (which we don't presently
# use).

internal-op Create-Val-Vec
type VV
eval frame[s.v1].vvec = new val_vec

# Appends v2 to the vector pointed to by v1.
internal-op Set-Val-Vec
type VV
eval auto v = frame[s.v2].ToVal(s.t)
eval frame[s.v1].vvec->push_back(v)

# Appends c to the vector pointed to by v1.
internal-op Set-Val-Vec
type VC
eval auto c = s.c.ToVal(s.t)
eval frame[s.v1].vvec->push_back(c)

# EXPR_INDEX
# EXPR_ANY_INDEX
# EXPR_HAS_FIELD
# EXPR_RECORD_CONSTRUCTOR
# EXPR_TABLE_CONSTRUCTOR
# EXPR_SET_CONSTRUCTOR
# EXPR_VECTOR_CONSTRUCTOR
# EXPR_IN
# EXPR_CALL
# EXPR_LAMBDA
# EXPR_ARITH_COERCE
# EXPR_RECORD_COERCE
# EXPR_TABLE_COERCE
# EXPR_VECTOR_COERCE

# EXPR_COND

# EXPR_FLATTEN
# EXPR_CAST
# EXPR_IS
