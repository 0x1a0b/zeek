# Templates used to generate virtual functions, opcodes, and evaluation
# code for compiled code.

########## Unary Ops ##########

unary-expr-op Assign
eval $1

unary-expr-op Clone
set-type $1
eval AS_ValUnion($1.ToVal(s.t)->Clone().release(), s.t)

unary-expr-op Size
set-type $1
eval AS_ValUnion($1.ToVal(s.t)->SizeVal().release(), s.t)

unary-expr-op Not
op-type I
eval ! $1

unary-expr-op Complement
op-type U
eval ~ $1

unary-expr-op Positive
op-type I D
vector
eval $1

unary-expr-op Negate
op-type I D
vector
eval -$1

unary-op AppendTo
eval auto vv = frame[s.v1].vector_val
eval vv->Assign(vv->Size(), $1.ToVal(s.t))

unary-op Flatten
op-type X
eval const char* error;
eval auto res = flatten_value(frame[s.v2].record_val, s.v3, error);
eval if ( error ) run_time_error(error);
eval frame[s.v1].record_val = res->AsRecordVal();

unary-op Cast
set-type $1
set-expr $2
eval const char* error
eval auto rhs = frame[s.v2].ToVal(s.e->Type().get()).get()
eval auto res = cast_value(rhs, s.t, error).get()
eval if ( error ) run_time_error(error)
eval frame[s.v1] = AS_ValUnion(res, s.t)

unary-op Is
set-type $1
set-expr $2
eval auto rhs = frame[s.v2].ToVal(s.e->Type().get()).get()
eval frame[s.v1].int_val = can_cast_value_to_type(rhs, s.t)

########## Binary Ops ##########

binary-expr-op Add
op-type I U D S
vector
eval $1 + $2
eval_S vector<const BroString*> strings
eval_S strings.push_back($1)
eval_S strings.push_back($2)
eval_S $$ = concatenate(strings)

binary-expr-op Sub
op-type I U D T
vector
eval $1 - $2
eval_T $$ = $1->Clone()->AsTableVal()
eval_T $2->RemoveFrom($$)

binary-expr-op Times
op-type I U D
vector
eval $1 * $2

binary-expr-op Divide
op-type I U D
vector
eval-pre if ( $2 == 0 ) run_time_error("division by zero")
eval $1 / $2

binary-expr-op Mod
op-type I U
vector
eval-pre if ( $2 == 0 ) run_time_error("modulo by zero")
eval $1 % $2

binary-expr-op And
op-type U P T
vector
eval $1 & $2
eval_P $$ = RE_Matcher_conjunction($1, $2)
eval_T $$ = $1->Intersect($2)

binary-expr-op Or
op-type U P T
vector
eval $1 | $2
eval_P $$ = RE_Matcher_disjunction($1, $2)
eval_T $$ = $1->Clone()->AsTableVal()
eval_T (void) $2->AddTo($$, false, false)

binary-expr-op Xor
op-type U
vector
eval $1 ^ $2

########## Relationals ##########

rel-expr-op LT
op-type I U D S T A
vector
eval $1 < $2
eval_S $$ = Bstr_cmp($1, $2) < 0
eval_T $$ = $1->IsSubsetOf($2) && $1->Size() < $2->Size()
eval_A $$ = *$1 < *$2

rel-expr-op LE
op-type I U D S T A
vector
eval $1 <= $2
eval_S $$ = Bstr_cmp($1, $2) <= 0
eval_T $$ = $1->IsSubsetOf($2)
eval_A $$ = *$1 < *$2 || *$1 == *$2

rel-expr-op EQ
op-type I U D S T A N
vector
eval $1 == $2
eval_S $$ = Bstr_cmp($1, $2) == 0
eval_T $$ = $1->EqualTo($2)
eval_A $$ = *$1 == *$2
eval_N $$ = *$1 == *$2
eval-mixed P S $$ = $1->MatchExactly($2)

rel-expr-op NE
op-type I U D S T A N
vector
eval $1 != $2
eval_S $$ = Bstr_cmp($1, $2) != 0
eval_T $$ = ! $1->EqualTo($2)
eval_A $$ = *$1 != *$2
eval_N $$ = *$1 != *$2
eval-mixed P S $$ = ! $1->MatchExactly($2)

# Note, canonicalization means that GE and GT shouldn't occur
# for Sets (type T).
rel-expr-op GE
op-type I U D S A
vector
eval $1 >= $2
eval_S $$ = Bstr_cmp($1, $2) >= 0
eval_A $$ = ! (*$1 < *$2)

rel-expr-op GT
op-type I U D S A
vector
eval $1 > $2
eval_S $$ = Bstr_cmp($1, $2) > 0
eval_A $$ = ! (*$1 < *$2) && *$1 != *$2

########## Nonuniform Expressions ##########

expr-op Field
type R
eval_R auto v = frame[s.v2].record_val->Lookup(s.v3)
eval_R if ( ! v ) { /* Check for &default */
eval_R	auto rt = s.t->AsRecordType()
eval_R	auto td = rt->FieldDecl(s.v3)
eval_R	const Attr* def_attr = td ? td->FindAttr(ATTR_DEFAULT) : 0
eval_R	if ( def_attr ) v = def_attr->AttrExpr()->Eval(nullptr).release()
eval_R	else run_time_error("field value missing")
eval_R	}
eval_R frame[s.v1] = AS_ValUnion(v, s.t)

expr-op Has_Field
type R
eval_R frame[s.v1].int_val = (frame[s.v2].record_val->Lookup(s.v3) != nullptr)

binary-expr-op In
custom-method return CompileInExpr($*);
no-eval

internal-op P-In-S
type VVV
eval frame[s.v1].int_val = frame[s.v2].re_val->MatchAnywhere(frame[s.v3].string_val) != 0

internal-op P-In-S
type VCV
eval frame[s.v1].int_val = s.c.re_val->MatchAnywhere(frame[s.v2].string_val) != 0

internal-op P-In-S
type VVC
eval frame[s.v1].int_val = frame[s.v2].re_val->MatchAnywhere(s.c.string_val) != 0

internal-binary-op S-In-S
op-accessor string_val
op-type I
eval auto sc = reinterpret_cast<const unsigned char*>(op1->CheckString())
eval $$ = strstr_n(op2->Len(), op2->Bytes(), op1->Len(), sc) != -1

internal-binary-op A-In-S
op1-accessor addr_val
op2-accessor subnet_val
op-type I
eval $$ = op2->Contains(*op1)

internal-binary-op U-In-V
op1-accessor uint_val
op2-accessor vector_val
op-type I
eval $$ = op2->Lookup(op1) != nullptr

# This one is handled differently because it has the unusual 2nd argument.
op L-In-T
type VLV
custom-method return CompileInExpr(n1, l, n2);
no-eval

internal-op Is-In-Table
type VVV
eval auto op1 = frame[s.v3].list_val
eval frame[s.v1].int_val = frame[s.v2].table_val->Lookup(op1) != nullptr

expr-op Cond
type VVVV
eval frame[s.v1] = frame[s.v2].int_val ? frame[s.v3] : frame[s.v4]

expr-op Cond
type VVVC
eval frame[s.v1] = frame[s.v2].int_val ? frame[s.v3] : s.c

expr-op Cond
type VVCV
eval frame[s.v1] = frame[s.v2].int_val ? s.c : frame[s.v3]

# Our statement structure doesn't accommodate two constants, so for
# the singular case of a V ? C1 : C2 conditional, we split it into
# two operations, V ? C1 and !V ? C2.
op CondC1
type VVC
eval if ( frame[s.v2].int_val ) frame[s.v1] = s.c

op CondC2
type VVC
eval if ( ! frame[s.v2].int_val ) frame[s.v1] = s.c

########## Index Expressions ##########

op IndexVecBoolSelect
type VVV
set-type $1
### track memory
eval if ( frame[s.v2].vector_val->Size() != frame[s.v3].vector_val->Size() ) {
eval	run_time_error("size mismatch, boolean index and vector"); }
eval auto vt = s.t->AsVectorType()
eval auto v = vector_bool_select(vt, frame[s.v2].vector_val, frame[s.v3].vector_val)
eval frame[s.v1].vector_val = v->AsVectorVal()

op IndexVecIntSelect
type VVV
set-type $1
eval auto vt = s.t->AsVectorType()
eval auto v = vector_int_select(vt, frame[s.v2].vector_val, frame[s.v3].vector_val)
eval frame[s.v1].vector_val = v->AsVectorVal()

op Index
type VVL
custom-method return CompileIndex(n1, n2, l);

internal-op Index-Vec
type VVL
eval auto v = frame[s.v2].vector_val->Lookup(frame[s.v3].list_val)
eval frame[s.v1] = AS_ValUnion(v, s.t)

internal-op Index-Vec-Slice
type VVL
### memory
eval auto vt = s.t->AsVectorType()
eval auto v = vector_index(vt, frame[s.v2].vector_val, frame[s.v3].list_val)
eval frame[s.v1] = AS_ValUnion(v.get(), s.t)

internal-op Table-Index
type VVV
### memory
eval auto v2 = frame[s.v3].list_val
eval auto v = frame[s.v2].table_val->Lookup(v2)
eval frame[s.v1] = AS_ValUnion(v.get(), s.t)

# This version is for a variable v3.
internal-op Index-String
type VVV
### memory
eval auto str = frame[s.v2].string_val
eval auto len = str->Len()
eval auto idx = frame[s.v3].int_val
eval if ( idx < 0 ) idx += len
eval frame[s.v1].string_val = str->GetSubstring(idx, 1)

# This version is for a constant v3.
internal-op Index-StringC
type VVV
### memory
eval auto str = frame[s.v2].string_val
eval auto len = str->Len()
eval auto idx = s.v3
eval if ( idx < 0 ) idx += len
eval frame[s.v1].string_val = str->GetSubstring(idx, 1)

internal-op Index-String-Slice
type VVL
### memory
eval auto str = frame[s.v2].string_val
eval auto lv = frame[s.v3].list_val
eval frame[s.v1].string_val = index_string_slice(str, lv)

op AnyIndex
type VVi
set-type $1
### memory
eval auto lv = frame[s.v2].any_val.val_list_val
eval frame[s.v1] = AS_ValUnion((*lv)[s.v3], s.t)

########## Function Calls ##########

# In principle, we could split these up into calls to other scripts
# functions vs. BiF's.  However, before biting that off we need to
# rework the Trigger framework so that it doesn't require CallExpr's
# to associate delayed values with.  This can be done by introducing
# an abstract TriggerCaller class that manages both CallExpr's and
# internal statements (e.g., associated with the PC value at the call
# site).  But for now, we just punt the whole problem to the interpreter.

direct-unary-op Call InterpretExpr


########## Constructors ##########

# Table construction requires atypical evaluation of list elements
# using information from their expression specifics.  We punt those
# back to the interpreter.
direct-unary-op Table-Constructor InterpretExpr

# In for a penny, in for a pound.  For now we just do all of them that
# way, even though with some elbow grease we could do the others directly.
direct-unary-op Set-Constructor InterpretExpr
direct-unary-op Record-Constructor InterpretExpr
direct-unary-op Vector-Constructor InterpretExpr

########## Coercions ##########

direct-unary-op Arith-Coerce ArithCoerce

internal-op Coerce-UI
type VV
eval frame[s.v1].uint_val = bro_uint_t(frame[s.v2].int_val)

internal-op Coerce-UI-Vec
type VV
### memory
eval frame[s.v1].raw_vector_val = vec_coerce_UI(frame[s.v2].raw_vector_val)

internal-op Coerce-UD
type VV
eval frame[s.v1].uint_val = bro_uint_t(frame[s.v2].double_val)

internal-op Coerce-UD-Vec
type VV
eval frame[s.v1].raw_vector_val = vec_coerce_UD(frame[s.v2].raw_vector_val)

internal-op Coerce-IU
type VV
eval frame[s.v1].int_val = bro_int_t(frame[s.v2].uint_val)

internal-op Coerce-IU-Vec
type VV
eval frame[s.v1].raw_vector_val = vec_coerce_IU(frame[s.v2].raw_vector_val)

internal-op Coerce-ID
type VV
eval frame[s.v1].int_val = bro_int_t(frame[s.v2].double_val)

internal-op Coerce-ID-Vec
type VV
eval frame[s.v1].raw_vector_val = vec_coerce_ID(frame[s.v2].raw_vector_val)

internal-op Coerce-DI
type VV
eval frame[s.v1].double_val = double(frame[s.v2].int_val)

internal-op Coerce-DI-Vec
type VV
eval frame[s.v1].raw_vector_val = vec_coerce_DI(frame[s.v2].raw_vector_val)

internal-op Coerce-DU
type VV
eval frame[s.v1].double_val = double(frame[s.v2].uint_val)

internal-op Coerce-DU-Vec
type VV
eval frame[s.v1].raw_vector_val = vec_coerce_DU(frame[s.v2].raw_vector_val)

direct-unary-op Record-Coerce RecordCoerce

internal-op Record-Coerce
type VVV
### memory
eval auto rt = s.t->AsRecordType()
eval auto v = frame[s.v2].record_val
eval auto map = s.int_ptr
eval auto map_size = s.v3
eval frame[s.v1].record_val = coerce_to_record(rt, v, map, map_size)->AsRecordVal()

direct-unary-op Table-Coerce TableCoerce

internal-op Table-Coerce
type VV
### memory
eval auto tv = frame[s.v2].table_val
eval if ( tv->Size() > 0 ) run_time_error("coercion of non-empty table/set");
eval IntrusivePtr<TableType> tt = {NewRef{}, s.t->AsTableType()}
eval IntrusivePtr<Attributes> attrs = {NewRef{}, tv->Attrs()}
eval frame[s.v1].table_val = new TableVal(tt, attrs)

direct-unary-op Vector-Coerce VectorCoerce

internal-op Vector-Coerce
type VV
### memory
eval auto vv = frame[s.v2].vector_val
eval if ( vv->Size() > 0 ) run_time_error("coercion of non-empty vector");
eval auto t = s.t->Ref()->AsVectorType();
eval frame[s.v1].vector_val = new VectorVal(t)

########## Aggregate Assignments ##########

op Field-LHS-Assign
type VVi
set-type $2
eval auto v = frame[s.v2].ToVal(s.t)
eval frame[s.v1].record_val->Assign(s.v3, v)
method-pre	SyncGlobals()

op Field-LHS-Assign
type VCi
set-type $2
eval auto v = s.c.ToVal(s.t)
eval frame[s.v1].record_val->Assign(s.v2, v)
method-pre	SyncGlobals()

########## General Statements ##########

op Schedule
type ViHL
custom-method return CompileSchedule(n, nullptr, i, h, l);
eval double dt = frame[s.v1].double_val
eval if ( s.v2 ) dt += network_time
eval auto handler = EventHandlerPtr(s.event_handler)
eval auto args = frame[s.v3].vvec
eval auto timer = new ScheduleTimer(s.event_handler, *args, dt)
eval timer_mgr->Add(timer)

op Schedule
type CiHL
custom-method return CompileSchedule(nullptr, c, i, h, l);
eval double dt = s.c.double_val
eval if ( s.v2 ) dt += network_time
eval auto hp = EventHandlerPtr(s.event_handler)
eval auto args = frame[s.v3].vvec
eval auto timer = new ScheduleTimer(s.event_handler, *args, dt)
eval timer_mgr->Add(timer)

op Event
type HL
custom-method return CompileEvent(h, l);
eval mgr.Enqueue(s.event_handler, *frame[s.v1].vvec)

op Return
type X
eval ret_u = nullptr
eval loop = false
method-pre	SyncGlobals()

op Return
type V
eval ret_u = &frame[s.v1]
eval ret_type = s.t
eval loop = false
method-pre	SyncGlobals()

op Return
type C
eval ret_u = &s.c
eval ret_type = s.t
eval loop = false
method-pre	SyncGlobals()

op Print
type O
eval auto vvec = frame[s.v1].vvec
eval do_print(*vvec)
eval delete vvec
method-pre int reg = v->n; delete v

internal-op If-Else
type VV
eval if ( ! frame[s.v1].int_val ) pc = s.v2

internal-op If
type VV
eval if ( ! frame[s.v1].int_val ) pc = s.v2

internal-op If-Not
type VV
eval if ( frame[s.v1].int_val ) pc = s.v2

internal-op GoTo
type V
eval pc = s.v1

op AddStmt
type VV
set-type $2
eval frame[s.v1].table_val->Assign(frame[s.v2].ToVal(s.t).get(), nullptr)

op AddStmt
type VC
set-type $2
eval frame[s.v1].table_val->Assign(s.c.ToVal(s.t).get(), nullptr)

op DelTable
type VV
set-type $2
eval frame[s.v1].table_val->Delete(frame[s.v2].ToVal(s.t).get())

op DelTable
type VC
set-type $2
eval frame[s.v1].table_val->Delete(s.c.ToVal(s.t).get())

op DelField
type Vi
eval frame[s.v1].record_val->Assign(s.v2, nullptr)


########################################
# Internal
########################################

# Initializes a new value vector.  We now do this dynamically, but at same
# point we could switch it to a static vector since we'll only have one of
# these at at time.
# 
# v1 is where to store the vector, v2 is its size (which we don't presently
# use).

internal-op Create-Val-Vec
type V
eval frame[s.v1].vvec = new val_vec

# Appends v2 to the vector pointed to by v1.
internal-op Set-Val-Vec
type VV
eval auto v = frame[s.v2].ToVal(s.t)
eval frame[s.v1].vvec->push_back(v)

# Appends c to the vector pointed to by v1.
internal-op Set-Val-Vec
type VC
eval auto c = s.c.ToVal(s.t)
eval frame[s.v1].vvec->push_back(c)

# Turns the vector at v2 (with v3 items) into a list_val at v1.  Deletes
# the original.
internal-op Transform-Val-Vec-To-List-Val
type VVV
eval frame[s.v1].list_val = ValVecToListVal(frame[s.v2].vvec, s.v3)

# Interprets the statement's expression as a stand-alone statement.
internal-op Interpret-Expr
type X
eval (void) s.e->Eval(f)

# Interprets the statement's expression and assigns the result to v1.
internal-op Interpret-Expr
type V
eval frame[s.v1] = AS_ValUnion(s.e->Eval(f).get(), s.t)
