# Templates used to generate virtual functions, opcodes, and evaluation
# code for compiled code.

########## Unary Ops ##########

unary-expr-op Assign
op-type A N S *
set-type $2
eval_A delete $$
eval_A $$ = new IPAddr(*$1)
eval_N delete $$
eval_N $$ = new IPPrefix(*$1)
eval_S delete $$
eval_S $$ = new BroString(*$1)
eval $1;

unary-expr-op Clone
op-type X
set-type $1
set-expr $2
eval auto v = frame[s.v2].ToVal(s.e->Type().get())->Clone();
eval frame[s.v1] = BuildVal(v, s.t, s.stmt);

unary-expr-op Size
op-type X
set-type $1
set-expr $2
eval auto v = frame[s.v2].ToVal(s.e->Type().get())->SizeVal();
eval frame[s.v1] = BuildVal(v, s.t, s.stmt);

unary-expr-op Not
op-type I
eval ! $1

unary-expr-op Complement
op-type U
eval ~ $1

unary-expr-op Positive
op-type I D
vector
eval $1

unary-expr-op Negate
op-type I D
vector
eval -$1

op IncrI
type V
eval ++frame[s.v1].int_val

op IncrU
type V
eval ++frame[s.v1].uint_val

op DecrI
type V
eval --frame[s.v1].int_val

op DecrU
type V
eval --frame[s.v1].uint_val

unary-op AppendTo
eval frame[s.v1].raw_vector_val->push_back($1)

unary-expr-op Flatten
op-type X
eval const char* error;
eval auto res = flatten_value(frame[s.v2].record_val, s.v3, error);
eval if ( error ) run_time_error(error_flag, s.stmt, error);
eval else frame[s.v1].record_val = res->AsRecordVal();

unary-expr-op Cast
op-type X
set-type $1
set-expr $2
eval const char* error;
eval auto rhs = frame[s.v2].ToVal(s.e->Type().get()).get();
eval auto res = cast_value(rhs, s.t, error);
eval if ( error ) run_time_error(error_flag, s.stmt, error);
eval else frame[s.v1] = BuildVal(res, s.t, s.stmt);

unary-expr-op Is
op-type X
set-type $1
set-expr $2
eval auto rhs = frame[s.v2].ToVal(s.e->Type().get()).get();
eval frame[s.v1].int_val = can_cast_value_to_type(rhs, s.t);

########## Binary Ops ##########

binary-expr-op Add
op-type I U D S
vector
eval $1 + $2
eval_S vector<const BroString*> strings
eval_S strings.push_back($1)
eval_S strings.push_back($2)
eval_S $$ = concatenate(strings)

binary-expr-op Sub
op-type I U D T
vector
eval $1 - $2
#
eval_T auto v = $1->Clone()
eval_T vals.push_back(v)
eval_T $$ = v->AsTableVal()
eval_T $2->RemoveFrom($$)

binary-expr-op Times
op-type I U D
vector
eval $1 * $2

binary-expr-op Divide
op-type I U D
set-expr $1
vector
#
eval-pre if ( $2 == 0 ) run_time_error(error_flag, s.stmt, "division by zero")
eval $1 / $2
#
eval-mixed A I auto mask = static_cast<uint32_t>($2)
eval-mixed A I auto a = $1
eval-mixed A I if ( a->GetFamily() == IPv4 && mask > 32 ) s.e->RuntimeError(fmt("bad IPv4 subnet prefix length: %" PRIu32, mask))
eval-mixed A I if ( a->GetFamily() == IPv6 && mask > 128 ) s.e->RuntimeError(fmt("bad IPv6 subnet prefix length: %" PRIu32, mask))
eval-mixed A I auto v = make_intrusive<SubNetVal>(*a, mask)
eval-mixed A I vals.push_back(v)
eval-mixed A I delete frame[s.v1].subnet_val
eval-mixed A I frame[s.v1].subnet_val = new IPPrefix(*v->val.subnet_val)
eval-mixed A I /* Note, $$ is ignored but mentioned here so templator backs off */

binary-expr-op Mod
op-type I U
vector
eval-pre if ( $2 == 0 ) run_time_error(error_flag, s.stmt, "modulo by zero")
eval $1 % $2

binary-expr-op And-And
op-type I
vector
eval $1 && $2

binary-expr-op Or-Or
op-type I
vector
eval $1 || $2

binary-expr-op And
op-type U P T
vector
eval $1 & $2
#
eval_P auto p = make_intrusive<PatternVal>(RE_Matcher_conjunction($1->AsPattern(), $2->AsPattern()))
eval_P vals.push_back(p)
eval_P $$ = p.get()
#
eval_T $$ = $1->Intersect($2)

binary-expr-op Or
op-type U P T
vector
eval $1 | $2
#
eval_P auto p = make_intrusive<PatternVal>(RE_Matcher_disjunction($1->AsPattern(), $2->AsPattern()))
eval_P vals.push_back(p)
eval_P $$ = p.get()
#
eval_T auto v = $1->Clone()
eval_T vals.push_back(v)
eval_T $$ = v->AsTableVal()
eval_T (void) $2->AddTo($$, false, false)

binary-expr-op Xor
op-type U
vector
eval $1 ^ $2

########## Relationals ##########

rel-expr-op LT
op-type I U D S T A
vector
eval $1 < $2
eval_S $$ = Bstr_cmp($1, $2) < 0
eval_T $$ = $1->IsSubsetOf($2) && $1->Size() < $2->Size()
eval_A $$ = *$1 < *$2

rel-expr-op LE
op-type I U D S T A
vector
eval $1 <= $2
eval_S $$ = Bstr_cmp($1, $2) <= 0
eval_T $$ = $1->IsSubsetOf($2)
eval_A $$ = *$1 < *$2 || *$1 == *$2

rel-expr-op EQ
op-type I U D S T A N
vector
eval $1 == $2
eval_S $$ = Bstr_cmp($1, $2) == 0
eval_T $$ = $1->EqualTo($2)
eval_A $$ = *$1 == *$2
eval_N $$ = *$1 == *$2
eval-mixed P S $$ = $1->AsPattern()->MatchExactly($2)

rel-expr-op NE
op-type I U D S T A N
vector
eval $1 != $2
eval_S $$ = Bstr_cmp($1, $2) != 0
eval_T $$ = ! $1->EqualTo($2)
eval_A $$ = *$1 != *$2
eval_N $$ = *$1 != *$2
eval-mixed P S $$ = ! $1->AsPattern()->MatchExactly($2)

# Note, canonicalization means that GE and GT shouldn't occur
# for Sets (type T).
rel-expr-op GE
op-type I U D S A
vector
eval $1 >= $2
eval_S $$ = Bstr_cmp($1, $2) >= 0
eval_A $$ = ! (*$1 < *$2)

rel-expr-op GT
op-type I U D S A
vector
eval $1 > $2
eval_S $$ = Bstr_cmp($1, $2) > 0
eval_A $$ = ! (*$1 < *$2) && *$1 != *$2

########## Nonuniform Expressions ##########

expr-op Field
type R
eval auto v = frame[s.v2].record_val->LookupWithDefault(s.v3)
eval if ( ! v ) s.e->RuntimeError("field value missing")
eval else frame[s.v1] = BuildVal(v, s.t, s.stmt)

expr-op Has-Field
type Ri
eval frame[s.v1].int_val = (frame[s.v2].record_val->Lookup(s.v3) != nullptr)

expr-op In
type VVV
custom-method return CompileInExpr($*);
no-eval

expr-op In
type VCV
custom-method return CompileInExpr($*);
no-eval

expr-op In
type VVC
custom-method return CompileInExpr($*);
no-eval

internal-op P-In-S
type VVV
eval frame[s.v1].int_val = frame[s.v2].re_val->AsPattern()->MatchAnywhere(frame[s.v3].string_val) != 0

internal-op P-In-S
type VCV
eval frame[s.v1].int_val = s.c.re_val->AsPattern()->MatchAnywhere(frame[s.v2].string_val) != 0

internal-op P-In-S
type VVC
eval frame[s.v1].int_val = frame[s.v2].re_val->AsPattern()->MatchAnywhere(s.c.string_val) != 0

internal-binary-op S-In-S
op-accessor string_val
op-type I
eval auto sc = reinterpret_cast<const unsigned char*>(op1->CheckString())
eval auto cmp = strstr_n(op2->Len(), op2->Bytes(), op1->Len(), sc)
eval $$ = cmp != -1

internal-binary-op A-In-S
op1-accessor addr_val
op2-accessor subnet_val
op-type I
eval $$ = op2->Contains(*op1)


# Handled differently because of the unusual middle argument.
op L-In-T
type VLV
custom-method return CompileInExpr(n1, l, n2);
no-eval

op L-In-Vec
type VLV
custom-method return CompileInExpr(n1, l, n2);
no-eval


internal-op Val-Is-In-Table
type VVV
eval auto op1 = frame[s.v2].ToVal(s.t)
eval frame[s.v1].int_val = frame[s.v3].table_val->Lookup(op1.get()) != nullptr

internal-op Const-Is-In-Table
type VCV
eval auto op1 = s.c.ToVal(s.t)
eval frame[s.v1].int_val = frame[s.v2].table_val->Lookup(op1.get()) != nullptr

internal-op List-Is-In-Table
type VVV
eval auto op1 = frame[s.v3].list_val
eval frame[s.v1].int_val = frame[s.v2].table_val->Lookup(op1) != nullptr

internal-op Index-Is-In-Vector
type VVV
set-type $2
eval auto op1 = frame[s.v3].list_val
eval auto op2 = frame[s.v2].ToVector(s.t)
eval frame[s.v1].int_val = op2->Lookup(op1) != nullptr

expr-op Cond
type VVVV
set-type $3
eval frame[s.v1] = frame[s.v2].int_val ? CopyVal(frame[s.v3]) : CopyVal(frame[s.v4])

expr-op Cond
type VVVC
set-type $3
eval frame[s.v1] = frame[s.v2].int_val ? CopyVal(frame[s.v3]) : CopyVal(s.c)

expr-op Cond
type VVCV
set-type $3
eval frame[s.v1] = frame[s.v2].int_val ? CopyVal(s.c) : CopyVal(frame[s.v3])

# Our statement structure doesn't accommodate two constants, so for
# the singular case of a V ? C1 : C2 conditional, we split it into
# two operations, V ? C1 and !V ? C2.
op CondC1
type VVC
set-type $1
eval if ( frame[s.v2].int_val ) frame[s.v1] = CopyVal(s.c)

op CondC2
set-type $1
type VVC
eval if ( ! frame[s.v2].int_val ) frame[s.v1] = CopyVal(s.c)

########## Index Expressions ##########

op IndexVecBoolSelect
type VVV
set-type $1
eval if ( frame[s.v2].raw_vector_val->size() != frame[s.v3].raw_vector_val->size() ) {
eval	run_time_error(error_flag, s.stmt, "size mismatch, boolean index and vector")
eval	break; }
eval auto vt = s.t->AsVectorType()
eval auto v2 = frame[s.v2].ToVector(vt)
eval auto v3 = frame[s.v3].ToVector(vt)
eval auto v = vector_bool_select(vt, v2.get(), v3.get())
eval delete frame[s.v1].raw_vector_val
eval frame[s.v1].raw_vector_val = to_raw_vector(v.get())

op IndexVecIntSelect
type VVV
set-type $1
eval auto vt = s.t->AsVectorType()
eval auto v2 = frame[s.v2].ToVector(vt)
eval auto v3 = frame[s.v3].ToVector(vt)
eval auto v = vector_int_select(vt, v2.get(), v3.get())
eval delete frame[s.v1].raw_vector_val
eval frame[s.v1].raw_vector_val = to_raw_vector(v.get())

op Index
type VVL
custom-method return CompileIndex(n1, n2, l);

internal-op Index-Vec
type VVL
eval auto yt = s.t->AsVectorType()->YieldType()
eval auto vec = frame[s.v2].ToVector(s.t)
eval auto v = vec->Lookup(frame[s.v3].list_val)
eval IntrusivePtr<Val> v_p = {NewRef{}, v}
eval frame[s.v1] = BuildVal(v_p, yt, s.stmt)

internal-op Index-Vec-Slice
type VVL
eval auto vt = s.t->AsVectorType()
eval auto vec = frame[s.v2].ToVector(s.t)
eval auto v = vector_index(vt, vec.get(), frame[s.v3].list_val)
eval delete frame[s.v1].raw_vector_val
eval frame[s.v1].raw_vector_val = to_raw_vector(v.get())

internal-op Table-Index
type VVV
eval auto v2 = frame[s.v3].list_val
eval auto v = frame[s.v2].table_val->Lookup(v2)
eval frame[s.v1] = BuildVal(v, s.t, s.stmt)

# This version is for a variable v3.
internal-op Index-String
type VVV
eval auto str = frame[s.v2].string_val
eval auto len = str->Len()
eval auto idx = frame[s.v3].int_val
eval if ( idx < 0 ) idx += len
eval auto v = str->GetSubstring(idx, 1)
eval delete frame[s.v1].string_val
eval frame[s.v1].string_val = v ? v : new BroString("")

# This version is for a constant v3.
internal-op Index-StringC
type VVV
eval auto str = frame[s.v2].string_val
eval auto len = str->Len()
eval auto idx = s.v3
eval if ( idx < 0 ) idx += len
eval auto v = str->GetSubstring(idx, 1)
eval delete frame[s.v1].string_val
eval frame[s.v1].string_val = v ? v : new BroString("")

internal-op Index-String-Slice
type VVL
eval auto str = frame[s.v2].string_val
eval auto lv = frame[s.v3].list_val
eval delete frame[s.v1].string_val
eval frame[s.v1].string_val = index_string_slice(str, lv)

op AnyIndex
type VVi
set-type $1
eval auto lv = frame[s.v2].any_val->val.val_list_val
eval auto elem = (*lv)[s.v3]
eval IntrusivePtr elem_p = {NewRef{}, elem}
eval frame[s.v1] = BuildVal(elem_p, s.t, s.stmt)


########## Constructors ##########

# Table construction requires atypical evaluation of list elements
# using information from their expression specifics.  We punt those
# back to the interpreter.
direct-unary-op Table-Constructor InterpretExpr

# In for a penny, in for a pound.  For now we just do all of them that
# way, even though with some elbow grease we could do the others directly.
direct-unary-op Set-Constructor InterpretExpr
direct-unary-op Record-Constructor InterpretExpr
direct-unary-op Vector-Constructor InterpretExpr

########## Coercions ##########

direct-unary-op Arith-Coerce ArithCoerce

internal-op Coerce-UI
type VV
eval frame[s.v1].uint_val = bro_uint_t(frame[s.v2].int_val)

internal-op Coerce-UI-Vec
type VV
eval delete frame[s.v1].raw_vector_val
eval frame[s.v1].raw_vector_val = vec_coerce_UI(frame[s.v2].raw_vector_val)

internal-op Coerce-UD
type VV
eval frame[s.v1].uint_val = bro_uint_t(frame[s.v2].double_val)

internal-op Coerce-UD-Vec
type VV
eval delete frame[s.v1].raw_vector_val
eval frame[s.v1].raw_vector_val = vec_coerce_UD(frame[s.v2].raw_vector_val)

internal-op Coerce-IU
type VV
eval frame[s.v1].int_val = bro_int_t(frame[s.v2].uint_val)

internal-op Coerce-IU-Vec
type VV
eval delete frame[s.v1].raw_vector_val
eval frame[s.v1].raw_vector_val = vec_coerce_IU(frame[s.v2].raw_vector_val)

internal-op Coerce-ID
type VV
eval frame[s.v1].int_val = bro_int_t(frame[s.v2].double_val)

internal-op Coerce-ID-Vec
type VV
eval delete frame[s.v1].raw_vector_val
eval frame[s.v1].raw_vector_val = vec_coerce_ID(frame[s.v2].raw_vector_val)

internal-op Coerce-DI
type VV
eval frame[s.v1].double_val = double(frame[s.v2].int_val)

internal-op Coerce-DI-Vec
type VV
eval delete frame[s.v1].raw_vector_val
eval frame[s.v1].raw_vector_val = vec_coerce_DI(frame[s.v2].raw_vector_val)

internal-op Coerce-DU
type VV
eval frame[s.v1].double_val = double(frame[s.v2].uint_val)

internal-op Coerce-DU-Vec
type VV
eval delete frame[s.v1].raw_vector_val
eval frame[s.v1].raw_vector_val = vec_coerce_DU(frame[s.v2].raw_vector_val)

direct-unary-op Record-Coerce RecordCoerce

internal-op Record-Coerce
type VVV
eval auto rt = s.t->AsRecordType()
eval auto v = frame[s.v2].record_val
eval auto map = s.int_ptr
eval auto map_size = s.v3
eval auto to_r = coerce_to_record(rt, v, map, map_size)
eval vals.push_back(to_r)
eval frame[s.v1].record_val = to_r->AsRecordVal()

direct-unary-op Table-Coerce TableCoerce

internal-op Table-Coerce
type VV
eval auto tv = frame[s.v2].table_val
eval if ( tv->Size() > 0 ) { run_time_error(error_flag, s.stmt, "coercion of non-empty table/set"); break; }
eval IntrusivePtr<TableType> tt = {NewRef{}, s.t->AsTableType()}
eval IntrusivePtr<Attributes> attrs = {NewRef{}, tv->Attrs()}
eval auto t = make_intrusive<TableVal>(tt, attrs)
eval vals.push_back(t)
eval frame[s.v1].table_val = t.get()

direct-unary-op Vector-Coerce VectorCoerce

internal-op Vector-Coerce
type VV
eval auto raw = frame[s.v2].raw_vector_val
eval if ( raw->size() > 0 ) { run_time_error(error_flag, s.stmt, "coercion of non-empty vector"); break; }
eval auto t = s.t->Ref()->AsVectorType();
eval auto vv_p = make_intrusive<VectorVal>(t)
eval delete frame[s.v1].raw_vector_val
eval frame[s.v1].raw_vector_val = to_raw_vector(vv_p.get())

########## Aggregate Assignments ##########

op Vector-Elem-Assign
type VVV
eval auto& vec = (*frame[s.v1].raw_vector_val)
eval vec[frame[s.v2].int_val] = frame[s.v3]

op Vector-Elem-Assign
type VVC
eval auto& vec = (*frame[s.v1].raw_vector_val)
eval vec[frame[s.v2].int_val] = s.c

# This version is used when the constant is the index, not the new value.
op Vector-Elem-Assign2
type VVC
eval auto& vec = (*frame[s.v1].raw_vector_val)
eval vec[s.c.int_val] = frame[s.v3]

# ... and when both are, and we've assigned the value to a temporary.
op Vector-Elem-Assign
type VCi
eval auto& vec = (*frame[s.v1].raw_vector_val)
eval vec[s.c.int_val] = frame[s.v2]

op Field-LHS-Assign
type VVi
set-type $2
eval auto v = frame[s.v2].ToVal(s.t)
eval frame[s.v1].record_val->Assign(s.v3, v)

op Field-LHS-Assign
type VCi
set-type $2
eval auto v = s.c.ToVal(s.t)
eval frame[s.v1].record_val->Assign(s.v2, v)

########## General Statements ##########

op Schedule
type ViHL
custom-method return CompileSchedule(n, nullptr, i, h, l);
eval double dt = frame[s.v1].double_val
eval if ( s.v2 ) dt += network_time
eval auto handler = EventHandlerPtr(s.event_handler)
eval auto args = frame[s.v3].vvec
eval auto timer = new ScheduleTimer(s.event_handler, std::move(*args), dt)
eval timer_mgr->Add(timer)

op Schedule
type CiHL
custom-method return CompileSchedule(nullptr, c, i, h, l);
eval double dt = s.c.double_val
eval if ( s.v1 ) dt += network_time
eval auto hp = EventHandlerPtr(s.event_handler)
eval auto args = frame[s.v2].vvec
eval auto timer = new ScheduleTimer(s.event_handler, std::move(*args), dt)
eval timer_mgr->Add(timer)


op Event
type HL
custom-method return CompileEvent(h, l);
eval mgr.Enqueue(s.event_handler, std::move(*frame[s.v1].vvec))


op Return
type X
eval ret_u = nullptr
eval pc = end_pc

op Return
type V
set-type $1
eval ret_u = &frame[s.v1]
eval ret_type = s.t
eval pc = end_pc

op Return
type C
eval ret_u = &s.c
eval ret_type = s.t
eval pc = end_pc


# Branch on the value of v1 using switch table v2, with default branch to v3
internal-op SwitchI
type VVV
eval auto v = frame[s.v1].int_val
eval auto t = int_cases[s.v2]
eval if ( t.find(v) == t.end() ) pc = s.v3
eval else pc = t[v]

internal-op SwitchU
type VVV
eval auto v = frame[s.v1].uint_val
eval auto t = uint_cases[s.v2]
eval if ( t.find(v) == t.end() ) pc = s.v3
eval else pc = t[v]

internal-op SwitchD
type VVV
eval auto v = frame[s.v1].double_val
eval auto t = double_cases[s.v2]
eval if ( t.find(v) == t.end() ) pc = s.v3
eval else pc = t[v]

internal-op SwitchS
type VVV
eval auto vs = frame[s.v1].string_val->Render()
eval std::string v(vs)
eval auto t = str_cases[s.v2]
eval if ( t.find(v) == t.end() ) pc = s.v3
eval else pc = t[v]
eval delete[] vs

internal-op SwitchA
type VVV
eval auto v = frame[s.v1].addr_val->AsString()
eval auto t = str_cases[s.v2]
eval if ( t.find(v) == t.end() ) pc = s.v3
eval else pc = t[v]

internal-op SwitchN
type VVV
eval auto v = frame[s.v1].subnet_val->AsString()
eval auto t = str_cases[s.v2]
eval if ( t.find(v) == t.end() ) pc = s.v3
eval else pc = t[v]


internal-op Branch-If-Not-Type
type VV
eval auto v = frame[s.v1].any_val
eval if ( ! can_cast_value_to_type(v, s.t) ) pc = s.v2;


internal-op Init-Table-Loop
type VV
eval auto ii = new IterInfo
eval ii->tv = frame[s.v2].table_val
eval ii->loop_vals = ii->tv->AsTable()
eval ii->c = ii->loop_vals->InitForIteration()
eval ii->value_var_type = s.t
eval frame[s.v1].iter_info = ii

internal-op Add-Var-To-Init
type VV
eval auto ii = frame[s.v1].iter_info
eval ii->loop_vars.push_back(s.v2)
eval ii->loop_var_types.push_back(s.t)

internal-op Next-Table-Iter
# v1 = iteration info
# v2 = branch target if loop done
type VV
eval HashKey* k
eval auto ii = frame[s.v1].iter_info
eval TableEntryVal* current_tev = ii->loop_vals->NextEntry(k, ii->c)
eval if ( ! current_tev ) { pc = s.v2; break; }
eval auto ind_lv = ii->tv->RecoverIndex(k);
eval delete k
eval for ( int i = 0; i < ind_lv->Length(); i++ ) {
eval	IntrusivePtr<Val> ind_lv_p = {NewRef{}, ind_lv->Index(i)}
eval	frame[ii->loop_vars[i]] = BuildVal(ind_lv_p, ii->loop_var_types[i], s.stmt)
eval }

internal-op Next-Table-Iter-Val-Var
# v1 = iteration info
# v2 = slot of the "ValueVar"
# v3 = branch target if loop done
type VVV
eval HashKey* k
eval auto ii = frame[s.v1].iter_info
eval TableEntryVal* current_tev = ii->loop_vals->NextEntry(k, ii->c)
eval if ( ! current_tev ) { pc = s.v3; break; }
eval auto ind_lv = ii->tv->RecoverIndex(k);
eval delete k
eval IntrusivePtr<Val> tev_p = {NewRef{}, current_tev->Value()}
eval frame[s.v2] = BuildVal(tev_p, ii->value_var_type, s.stmt)
eval for ( int i = 0; i < ind_lv->Length(); i++ ) {
eval	IntrusivePtr<Val> ind_lv_p = {NewRef{}, ind_lv->Index(i)}
eval	frame[ii->loop_vars[i]] = BuildVal(ind_lv_p, ii->loop_var_types[i], s.stmt)
eval }

internal-op Init-Vector-Loop
type VV
eval auto ii = new IterInfo
eval ii->vv = frame[s.v2].raw_vector_val
eval ii->vec_type = s.t->AsVectorType()
eval ii->iter = 0
eval ii->n = ii->vv->size()
eval ii->c = 0;	// because End-Loop will check it
eval frame[s.v1].iter_info = ii

internal-op Next-Vector-Iter
type VVV
eval auto ii = frame[s.v1].iter_info
eval if ( ii->iter >= ii->n ) { pc = s.v3; break; }
eval auto& vv = *ii->vv
eval if ( vv[ii->iter].IsNil(ii->vec_type) ) { ++ii->iter; --pc; break; }
eval frame[s.v2].uint_val = ii->iter
eval ++ii->iter

internal-op Init-String-Loop
type VV
eval auto ii = new IterInfo
eval ii->s = frame[s.v2].string_val
eval ii->iter = 0
eval ii->n = ii->s->Len()
eval ii->c = 0;	// because End-Loop will check it
eval frame[s.v1].iter_info = ii

internal-op Next-String-Iter
type VVV
eval auto ii = frame[s.v1].iter_info
eval auto sval = ii->s
eval if ( ii->iter >= ii->n ) { pc = s.v3; break; }
eval auto bytes = (const char*) sval->Bytes() + ii->iter
eval auto sv = new StringVal(1, bytes)
eval delete frame[s.v2].string_val
eval frame[s.v2].string_val = new BroString(*sv->AsString())
eval delete sv
eval ++ii->iter

internal-op End-Loop
type V
eval auto ii = frame[s.v1].iter_info
eval if ( ii->c ) ii->loop_vals->StopIteration(ii->c)
eval delete ii


op When
type VVVV
eval auto when_body = new ResumptionAM(this, s.v2)
eval auto timeout_body = new ResumptionAM(this, s.v3)
eval new trigger::Trigger(s.non_const_e, when_body, timeout_body, frame[s.v1].double_val, f, s.v4, s.stmt->GetLocationInfo())

op When
type VVVC
eval auto when_body = new ResumptionAM(this, s.v2)
eval auto timeout_body = new ResumptionAM(this, s.v3)
eval new trigger::Trigger(s.non_const_e, when_body, timeout_body, s.c.double_val, f, s.v4, s.stmt->GetLocationInfo())

op When
type VV
eval auto when_body = new ResumptionAM(this, s.v2)
eval new trigger::Trigger(s.non_const_e, when_body, nullptr, -1.0, f, s.v4, s.stmt->GetLocationInfo())

op CheckAnyLen
type Vi
eval auto v = frame[s.v1].list_val
eval if ( v->Vals()->length() != s.v2 ) run_time_error(error_flag, s.stmt, "mismatch in list lengths")

op Print
type O
eval auto vvec = frame[s.v1].vvec
eval do_print(*vvec)
eval delete vvec
method-pre int reg = v->n; delete v


internal-op If-Else
type VV
eval if ( ! frame[s.v1].int_val ) pc = s.v2

internal-op If
type VV
eval if ( ! frame[s.v1].int_val ) pc = s.v2

internal-op If-Not
type VV
eval if ( frame[s.v1].int_val ) pc = s.v2


op AddStmt
type VO
eval auto vvec = frame[s.v2].vvec
eval auto lval = ValVecToListVal(vvec, vvec->size())
eval frame[s.v1].table_val->Assign(lval, nullptr)
eval delete lval
method-pre int reg = v->n; delete v


op DelTable
type VO
eval auto vvec = frame[s.v2].vvec
eval auto lval = ValVecToListVal(vvec, vvec->size())
eval frame[s.v1].table_val->Delete(lval)
eval delete lval
method-pre int reg = v->n; delete v

op DelField
type Vi
eval frame[s.v1].record_val->Assign(s.v2, nullptr)


internal-op Init-Record
type V
eval frame[s.v1].record_val = new RecordVal(s.t->AsRecordType())

internal-op Init-Vector
type V
eval delete frame[s.v1].raw_vector_val
eval frame[s.v1].raw_vector_val = new AS_vector;

internal-op Init-Table
type V
eval IntrusivePtr<TableType> tt = {NewRef{}, s.t->AsTableType()}
eval IntrusivePtr<Attributes> attrs = {NewRef{}, s.attrs}
eval frame[s.v1].table_val = new TableVal(tt, attrs)


########################################
# Internal
########################################

op Assign-Any
type VV
set-type $2
eval auto v = frame[s.v2].ToVal(s.t)
eval vals.push_back(v)
eval frame[s.v1].any_val = v.get()

op Assign-Any
type VC
set-type $2
eval auto v = s.c.ToVal(s.t)
eval vals.push_back(v)
eval frame[s.v1].any_val = v.get()

# Lazy way to assign without having to track the specific type of
# a constant.
internal-op Assign-Const
type VC
eval frame[s.v1] = BuildVal(s.c.ToVal(s.t), s.t, nullptr)

internal-op Load-Val
type VV
eval auto v = f->NthElement(s.v2)
eval if ( ! v ) reporter->InternalError("failure to load frame element");
eval IntrusivePtr<Val> v_p = {NewRef{}, v}
eval frame[s.v1] = BuildVal(v_p, s.t, v)

internal-op Load-Any-Val
type VV
eval IntrusivePtr<Val> v = {NewRef{}, f->NthElement(s.v2)}
eval vals.push_back(v)
eval frame[s.v1].any_val = v.get()

internal-op Load-Global
type VC
eval IntrusivePtr<Val> v = {NewRef{}, s.c.id_val->ID_Val()}
eval frame[s.v1] = BuildVal(v, s.t, s.c.id_val)

internal-op Load-Any-Global
type VC
eval IntrusivePtr<Val> v = {NewRef{}, s.c.id_val->ID_Val()}
eval vals.push_back(v)
eval frame[s.v1].any_val = v.get()

internal-op Store-Val
type VV
eval auto v = frame[s.v1].ToVal(s.t)
eval f->SetElement(s.v2, v.release())

internal-op Store-Any-Val
type VV
eval auto v = frame[s.v1].any_val->Ref()
eval f->SetElement(s.v2, v)

internal-op Store-Global
type VC
eval auto v = frame[s.v1].ToVal(s.t)
eval s.c.id_val->SetVal(v)

internal-op Store-Any-Global
type VC
eval IntrusivePtr<Val> v = {NewRef{}, frame[s.v1].any_val}
eval s.c.id_val->SetVal(v)

internal-op Copy-To
type VC
set-type $2
eval frame[s.v1] = CopyVal(s.c)

# Initializes a new value vector.  We now do this dynamically, but at same
# point we could switch it to a static vector since we'll only have one of
# these at at time.
# 
# v1 is where to store the vector, v2 is its size (which we don't presently
# use).

internal-op Create-Val-Vec
type V
eval frame[s.v1].vvec = new val_vec

# Appends v2 to the vector pointed to by v1.
internal-op Set-Val-Vec
type VV
eval auto v = frame[s.v2].ToVal(s.t)
eval frame[s.v1].vvec->push_back(v)

# Appends c to the vector pointed to by v1.
internal-op Set-Val-Vec
type VC
eval auto c = s.c.ToVal(s.t)
eval frame[s.v1].vvec->push_back(c)

# Turns the vector at v2 (with v3 items) into a list_val at v1.  Deletes
# the original.
internal-op Transform-Val-Vec-To-List-Val
type VVV
eval frame[s.v1].list_val = ValVecToListVal(frame[s.v2].vvec, s.v3)

# Interprets the statement's expression as a stand-alone statement.
internal-op Interpret-Expr
type X
eval (void) s.e->Eval(f)

# Interprets the statement's expression and assigns the result to v1.
internal-op Interpret-Expr
type V
eval auto v = s.e->Eval(f)
eval frame[s.v1] = BuildVal(v, s.t, s.e)

internal-op GoTo
type V
eval pc = s.v1

internal-op Hook-Break
type X
eval flow = FLOW_BREAK
eval pc = end_pc
