# Templates used to generate virtual functions, opcodes, and evaluation
# code for compiled code.

########## Unary Ops ##########

unary-expr-op Assign
eval $1

unary-expr-op Clone
set-type $1
eval AS_ValUnion($1.ToVal(s.t)->Clone().release(), s.t, s.stmt, error_flag)

unary-expr-op Size
set-type $1
eval AS_ValUnion($1.ToVal(s.t)->SizeVal().release(), s.t, s.stmt, error_flag)

unary-expr-op Not
op-type I
eval ! $1

unary-expr-op Complement
op-type U
eval ~ $1

unary-expr-op Positive
op-type I D
vector
eval $1

unary-expr-op Negate
op-type I D
vector
eval -$1

unary-op AppendTo
eval auto vv = frame[s.v1].vector_val;
eval vv->Assign(vv->Size(), $1.ToVal(s.t));

unary-expr-op Flatten
op-type X
eval const char* error;
eval auto res = flatten_value(frame[s.v2].record_val, s.v3, error);
eval if ( error ) run_time_error(error_flag, s.stmt, error);
eval else frame[s.v1].record_val = res->AsRecordVal();

unary-expr-op Cast
op-type X
set-type $1
set-expr $2
eval const char* error;
eval auto rhs = frame[s.v2].ToVal(s.e->Type().get()).get();
eval auto res = cast_value(rhs, s.t, error).get();
eval if ( error ) run_time_error(error_flag, s.stmt, error);
eval else frame[s.v1] = AS_ValUnion(res, s.t, s.stmt, error_flag);

unary-op Is
set-type $1
set-expr $2
eval auto rhs = frame[s.v2].ToVal(s.e->Type().get()).get()
eval frame[s.v1].int_val = can_cast_value_to_type(rhs, s.t)

########## Binary Ops ##########

binary-expr-op Add
op-type I U D S
vector
eval $1 + $2
eval_S vector<const BroString*> strings
eval_S strings.push_back($1)
eval_S strings.push_back($2)
eval_S $$ = concatenate(strings)

binary-expr-op Sub
op-type I U D T
vector
eval $1 - $2
eval_T $$ = $1->Clone()->AsTableVal()
eval_T $2->RemoveFrom($$)

binary-expr-op Times
op-type I U D
vector
eval $1 * $2

binary-expr-op Divide
op-type I U D
vector
eval-pre if ( $2 == 0 ) run_time_error(error_flag, s.stmt, "division by zero")
eval $1 / $2

binary-expr-op Mod
op-type I U
vector
eval-pre if ( $2 == 0 ) run_time_error(error_flag, s.stmt, "modulo by zero")
eval $1 % $2

binary-expr-op And-And
op-type I
vector
eval $1 && $2

binary-expr-op Or-Or
op-type I
vector
eval $1 || $2

binary-expr-op And
op-type U P T
vector
eval $1 & $2
eval_P $$ = new PatternVal(RE_Matcher_conjunction($1->AsPattern(), $2->AsPattern()))
eval_T $$ = $1->Intersect($2)

binary-expr-op Or
op-type U P T
vector
eval $1 | $2
eval_P $$ = new PatternVal(RE_Matcher_disjunction($1->AsPattern(), $2->AsPattern()))
eval_T $$ = $1->Clone()->AsTableVal()
eval_T (void) $2->AddTo($$, false, false)

binary-expr-op Xor
op-type U
vector
eval $1 ^ $2

########## Relationals ##########

rel-expr-op LT
op-type I U D S T A
vector
eval $1 < $2
eval_S $$ = Bstr_cmp($1, $2) < 0
eval_T $$ = $1->IsSubsetOf($2) && $1->Size() < $2->Size()
eval_A $$ = *$1 < *$2

rel-expr-op LE
op-type I U D S T A
vector
eval $1 <= $2
eval_S $$ = Bstr_cmp($1, $2) <= 0
eval_T $$ = $1->IsSubsetOf($2)
eval_A $$ = *$1 < *$2 || *$1 == *$2

rel-expr-op EQ
op-type I U D S T A N
vector
eval $1 == $2
eval_S $$ = Bstr_cmp($1, $2) == 0
eval_T $$ = $1->EqualTo($2)
eval_A $$ = *$1 == *$2
eval_N $$ = *$1 == *$2
eval-mixed P S $$ = $1->AsPattern()->MatchExactly($2)

rel-expr-op NE
op-type I U D S T A N
vector
eval $1 != $2
eval_S $$ = Bstr_cmp($1, $2) != 0
eval_T $$ = ! $1->EqualTo($2)
eval_A $$ = *$1 != *$2
eval_N $$ = *$1 != *$2
eval-mixed P S $$ = ! $1->AsPattern()->MatchExactly($2)

# Note, canonicalization means that GE and GT shouldn't occur
# for Sets (type T).
rel-expr-op GE
op-type I U D S A
vector
eval $1 >= $2
eval_S $$ = Bstr_cmp($1, $2) >= 0
eval_A $$ = ! (*$1 < *$2)

rel-expr-op GT
op-type I U D S A
vector
eval $1 > $2
eval_S $$ = Bstr_cmp($1, $2) > 0
eval_A $$ = ! (*$1 < *$2) && *$1 != *$2

########## Nonuniform Expressions ##########

expr-op Field
type R
eval auto v = frame[s.v2].record_val->Lookup(s.v3)
eval if ( ! v ) { /* Check for &default */
eval	auto rt = s.t->AsRecordType()
eval	auto td = rt->FieldDecl(s.v3)
eval	const Attr* def_attr = td ? td->FindAttr(ATTR_DEFAULT) : 0
eval	if ( def_attr ) v = def_attr->AttrExpr()->Eval(nullptr).release()
eval	else { run_time_error(error_flag, s.stmt, "field value missing"); break; }
eval	}
eval frame[s.v1] = AS_ValUnion(v, s.t, s.stmt, error_flag)

expr-op Has_Field
type Ri
eval frame[s.v1].int_val = (frame[s.v2].record_val->Lookup(s.v3) != nullptr)

expr-op In
type VVV
custom-method return CompileInExpr($*);
no-eval

expr-op In
type VCV
custom-method return CompileInExpr($*);
no-eval

internal-op P-In-S
type VVV
eval frame[s.v1].int_val = frame[s.v2].re_val->AsPattern()->MatchAnywhere(frame[s.v3].string_val) != 0

internal-op P-In-S
type VCV
eval frame[s.v1].int_val = s.c.re_val->AsPattern()->MatchAnywhere(frame[s.v2].string_val) != 0

internal-op P-In-S
type VVC
eval frame[s.v1].int_val = frame[s.v2].re_val->AsPattern()->MatchAnywhere(s.c.string_val) != 0

internal-binary-op S-In-S
op-accessor string_val
op-type I
eval auto sc = reinterpret_cast<const unsigned char*>(op1->CheckString())
eval $$ = strstr_n(op2->Len(), op2->Bytes(), op1->Len(), sc) != -1

internal-binary-op A-In-S
op1-accessor addr_val
op2-accessor subnet_val
op-type I
eval $$ = op2->Contains(*op1)

internal-binary-op U-In-V
op1-accessor uint_val
op2-accessor vector_val
op-type I
eval $$ = op2->Lookup(op1) != nullptr


# Handled differently because of the unusual middle argument.
op L-In-T
type VLV
custom-method return CompileInExpr(n1, l, n2);
no-eval

op L-In-Vec
type VLV
custom-method return CompileInExpr(n1, l, n2);
no-eval


internal-op Val-Is-In-Table
type VVV
eval auto op1 = frame[s.v2].ToVal(s.t)
eval frame[s.v1].int_val = frame[s.v3].table_val->Lookup(op1.get()) != nullptr

internal-op Const-Is-In-Table
type VCV
eval auto op1 = s.c.ToVal(s.t)
eval frame[s.v1].int_val = frame[s.v2].table_val->Lookup(op1.get()) != nullptr

internal-op List-Is-In-Table
type VVV
eval auto op1 = frame[s.v3].list_val
eval frame[s.v1].int_val = frame[s.v2].table_val->Lookup(op1) != nullptr

expr-op Cond
type VVVV
eval frame[s.v1] = frame[s.v2].int_val ? frame[s.v3] : frame[s.v4]

expr-op Cond
type VVVC
eval frame[s.v1] = frame[s.v2].int_val ? frame[s.v3] : s.c

expr-op Cond
type VVCV
eval frame[s.v1] = frame[s.v2].int_val ? s.c : frame[s.v3]

# Our statement structure doesn't accommodate two constants, so for
# the singular case of a V ? C1 : C2 conditional, we split it into
# two operations, V ? C1 and !V ? C2.
op CondC1
type VVC
eval if ( frame[s.v2].int_val ) frame[s.v1] = s.c

op CondC2
type VVC
eval if ( ! frame[s.v2].int_val ) frame[s.v1] = s.c

########## Index Expressions ##########

op IndexVecBoolSelect
type VVV
set-type $1
### track memory
eval if ( frame[s.v2].vector_val->Size() != frame[s.v3].vector_val->Size() ) {
eval	run_time_error(error_flag, s.stmt, "size mismatch, boolean index and vector")
eval	break; }
eval auto vt = s.t->AsVectorType()
eval auto v = vector_bool_select(vt, frame[s.v2].vector_val, frame[s.v3].vector_val)
eval frame[s.v1].vector_val = v->AsVectorVal()

op IndexVecIntSelect
type VVV
set-type $1
eval auto vt = s.t->AsVectorType()
eval auto v = vector_int_select(vt, frame[s.v2].vector_val, frame[s.v3].vector_val)
eval frame[s.v1].vector_val = v->AsVectorVal()

op Index
type VVL
custom-method return CompileIndex(n1, n2, l);

internal-op Index-Vec
type VVL
eval auto v = frame[s.v2].vector_val->Lookup(frame[s.v3].list_val)
eval frame[s.v1] = AS_ValUnion(v, s.t, s.stmt, error_flag)

internal-op Index-Vec-Slice
type VVL
### memory
eval auto vt = s.t->AsVectorType()
eval auto v = vector_index(vt, frame[s.v2].vector_val, frame[s.v3].list_val)
eval frame[s.v1] = AS_ValUnion(v.get(), s.t, s.stmt, error_flag)

internal-op Table-Index
type VVV
### memory
eval auto v2 = frame[s.v3].list_val
eval auto v = frame[s.v2].table_val->Lookup(v2)
eval frame[s.v1] = AS_ValUnion(v.get(), s.t, s.stmt, error_flag)

# This version is for a variable v3.
internal-op Index-String
type VVV
### memory
eval auto str = frame[s.v2].string_val
eval auto len = str->Len()
eval auto idx = frame[s.v3].int_val
eval if ( idx < 0 ) idx += len
eval frame[s.v1].string_val = str->GetSubstring(idx, 1)

# This version is for a constant v3.
internal-op Index-StringC
type VVV
### memory
eval auto str = frame[s.v2].string_val
eval auto len = str->Len()
eval auto idx = s.v3
eval if ( idx < 0 ) idx += len
eval frame[s.v1].string_val = str->GetSubstring(idx, 1)

internal-op Index-String-Slice
type VVL
### memory
eval auto str = frame[s.v2].string_val
eval auto lv = frame[s.v3].list_val
eval frame[s.v1].string_val = index_string_slice(str, lv)

op AnyIndex
type VVi
set-type $1
### memory
eval auto lv = frame[s.v2].any_val->val.val_list_val
eval frame[s.v1] = AS_ValUnion((*lv)[s.v3], s.t, s.stmt, error_flag)

########## Function Calls ##########

# In principle, we could split these up into calls to other scripts
# functions vs. BiF's.  However, before biting that off we need to
# rework the Trigger framework so that it doesn't require CallExpr's
# to associate delayed values with.  This can be done by introducing
# an abstract TriggerCaller class that manages both CallExpr's and
# internal statements (e.g., associated with the PC value at the call
# site).  But for now, we just punt the whole problem to the interpreter.

direct-unary-op Call InterpretExpr


########## Constructors ##########

# Table construction requires atypical evaluation of list elements
# using information from their expression specifics.  We punt those
# back to the interpreter.
direct-unary-op Table-Constructor InterpretExpr

# In for a penny, in for a pound.  For now we just do all of them that
# way, even though with some elbow grease we could do the others directly.
direct-unary-op Set-Constructor InterpretExpr
direct-unary-op Record-Constructor InterpretExpr
direct-unary-op Vector-Constructor InterpretExpr

########## Coercions ##########

direct-unary-op Arith-Coerce ArithCoerce

internal-op Coerce-UI
type VV
eval frame[s.v1].uint_val = bro_uint_t(frame[s.v2].int_val)

internal-op Coerce-UI-Vec
type VV
### memory
eval frame[s.v1].raw_vector_val = vec_coerce_UI(frame[s.v2].raw_vector_val)

internal-op Coerce-UD
type VV
eval frame[s.v1].uint_val = bro_uint_t(frame[s.v2].double_val)

internal-op Coerce-UD-Vec
type VV
eval frame[s.v1].raw_vector_val = vec_coerce_UD(frame[s.v2].raw_vector_val)

internal-op Coerce-IU
type VV
eval frame[s.v1].int_val = bro_int_t(frame[s.v2].uint_val)

internal-op Coerce-IU-Vec
type VV
eval frame[s.v1].raw_vector_val = vec_coerce_IU(frame[s.v2].raw_vector_val)

internal-op Coerce-ID
type VV
eval frame[s.v1].int_val = bro_int_t(frame[s.v2].double_val)

internal-op Coerce-ID-Vec
type VV
eval frame[s.v1].raw_vector_val = vec_coerce_ID(frame[s.v2].raw_vector_val)

internal-op Coerce-DI
type VV
eval frame[s.v1].double_val = double(frame[s.v2].int_val)

internal-op Coerce-DI-Vec
type VV
eval frame[s.v1].raw_vector_val = vec_coerce_DI(frame[s.v2].raw_vector_val)

internal-op Coerce-DU
type VV
eval frame[s.v1].double_val = double(frame[s.v2].uint_val)

internal-op Coerce-DU-Vec
type VV
eval frame[s.v1].raw_vector_val = vec_coerce_DU(frame[s.v2].raw_vector_val)

direct-unary-op Record-Coerce RecordCoerce

internal-op Record-Coerce
type VVV
### memory
eval auto rt = s.t->AsRecordType()
eval auto v = frame[s.v2].record_val
eval auto map = s.int_ptr
eval auto map_size = s.v3
eval frame[s.v1].record_val = coerce_to_record(rt, v, map, map_size)->AsRecordVal()

direct-unary-op Table-Coerce TableCoerce

internal-op Table-Coerce
type VV
### memory
eval auto tv = frame[s.v2].table_val
eval if ( tv->Size() > 0 ) { run_time_error(error_flag, s.stmt, "coercion of non-empty table/set"); break; }
eval IntrusivePtr<TableType> tt = {NewRef{}, s.t->AsTableType()}
eval IntrusivePtr<Attributes> attrs = {NewRef{}, tv->Attrs()}
eval frame[s.v1].table_val = new TableVal(tt, attrs)

direct-unary-op Vector-Coerce VectorCoerce

internal-op Vector-Coerce
type VV
### memory
eval auto vv = frame[s.v2].vector_val
eval if ( vv->Size() > 0 ) { run_time_error(error_flag, s.stmt, "coercion of non-empty vector"); break; }
eval auto t = s.t->Ref()->AsVectorType();
eval frame[s.v1].vector_val = new VectorVal(t)

########## Aggregate Assignments ##########

op Field-LHS-Assign
type VVi
set-type $2
eval auto v = frame[s.v2].ToVal(s.t)
eval frame[s.v1].record_val->Assign(s.v3, v)

op Field-LHS-Assign
type VCi
set-type $2
eval auto v = s.c.ToVal(s.t)
eval frame[s.v1].record_val->Assign(s.v2, v)

########## General Statements ##########

op Schedule
type ViHL
custom-method return CompileSchedule(n, nullptr, i, h, l);
eval double dt = frame[s.v1].double_val
eval if ( s.v2 ) dt += network_time
eval auto handler = EventHandlerPtr(s.event_handler)
eval auto args = frame[s.v3].vvec
eval auto timer = new ScheduleTimer(s.event_handler, *args, dt)
eval timer_mgr->Add(timer)

op Schedule
type CiHL
custom-method return CompileSchedule(nullptr, c, i, h, l);
eval double dt = s.c.double_val
eval if ( s.v2 ) dt += network_time
eval auto hp = EventHandlerPtr(s.event_handler)
eval auto args = frame[s.v3].vvec
eval auto timer = new ScheduleTimer(s.event_handler, *args, dt)
eval timer_mgr->Add(timer)


op Event
type HL
custom-method return CompileEvent(h, l);
eval mgr.Enqueue(s.event_handler, *frame[s.v1].vvec)


op Return
type X
eval ret_u = nullptr
eval pc = end_pc

op Return
type V
eval ret_u = &frame[s.v1]
eval ret_type = s.t
eval pc = end_pc

op Return
type C
eval ret_u = &s.c
eval ret_type = s.t
eval pc = end_pc


internal-op Branch-If-Not-Type
type VV
eval auto v = frame[s.v1].any_val
eval if ( ! can_cast_value_to_type(v, s.t) ) pc = s.v2;

internal-op Branch-If-Not-Int
type VVC
eval if ( frame[s.v1].int_val != s.c.int_val ) pc = s.v2

internal-op Branch-If-Not-UInt
type VVC
eval if ( frame[s.v1].uint_val != s.c.uint_val ) pc = s.v2

internal-op Branch-If-Not-Addr
type VVC
eval if ( *frame[s.v1].addr_val != *s.c.addr_val ) pc = s.v2

internal-op Branch-If-Not-Subnet
type VVC
eval if ( *frame[s.v1].subnet_val != *s.c.subnet_val ) pc = s.v2

internal-op Branch-If-Not-Double
type VVC
eval if ( frame[s.v1].double_val != s.c.double_val ) pc = s.v2

internal-op Branch-If-Not-String
type VVC
eval if ( ! ((*frame[s.v1].string_val) == (*s.c.string_val)) ) pc = s.v2


internal-op Init-Table-Loop
type VV
eval auto ii = new IterInfo
eval ii->tv = frame[s.v2].table_val
eval ii->loop_vals = ii->tv->AsTable()
eval ii->c = ii->loop_vals->InitForIteration()
eval ii->value_var_type = s.t
eval frame[s.v1].iter_info = ii

internal-op Add-Var-To-Init
type VV
eval auto ii = frame[s.v1].iter_info
eval ii->loop_vars.push_back(s.v2)
eval ii->loop_var_types.push_back(s.t)

internal-op Next-Table-Iter
# v1 = iteration info
# v2 = branch target if loop done
type VV
eval HashKey* k
eval auto ii = frame[s.v1].iter_info
eval TableEntryVal* current_tev = ii->loop_vals->NextEntry(k, ii->c)
eval if ( ! current_tev ) { pc = s.v2; break; }
eval auto ind_lv = ii->tv->RecoverIndex(k);
eval delete k
eval for ( int i = 0; i < ind_lv->Length(); i++ ) frame[ii->loop_vars[i]] = AS_ValUnion(ind_lv->Index(i)->Ref(), ii->loop_var_types[i], s.stmt, error_flag)

internal-op Next-Table-Iter-Val-Var
# v1 = iteration info
# v2 = slot of the "ValueVar"
# v3 = branch target if loop done
type VVV
eval HashKey* k
eval auto ii = frame[s.v1].iter_info
eval TableEntryVal* current_tev = ii->loop_vals->NextEntry(k, ii->c)
eval if ( ! current_tev ) { pc = s.v3; break; }
eval auto ind_lv = ii->tv->RecoverIndex(k);
eval delete k
eval frame[s.v2] = AS_ValUnion(current_tev->Value()->Ref(), ii->value_var_type, s.stmt, error_flag)
eval for ( int i = 0; i < ind_lv->Length(); i++ ) frame[ii->loop_vars[i]] = AS_ValUnion(ind_lv->Index(i)->Ref(), ii->loop_var_types[i], s.stmt, error_flag)

internal-op Init-Vector-Loop
type VV
eval auto ii = new IterInfo
eval ii->vv = frame[s.v2].vector_val
eval ii->iter = 0
eval ii->n = ii->vv->Size()
eval ii->c = 0;	// because End-Loop will check it
eval frame[s.v1].iter_info = ii

internal-op Next-Vector-Iter
type VVV
eval auto ii = frame[s.v1].iter_info
eval if ( ii->iter >= ii->n ) { pc = s.v3; break; }
eval auto vv = ii->vv
eval if ( ! vv->Lookup(ii->iter) ) { ++ii->iter; --pc; break; }
eval frame[s.v2].uint_val = ii->iter
eval ++ii->iter

internal-op Init-String-Loop
type VV
eval auto ii = new IterInfo
eval ii->s = frame[s.v2].string_val
eval ii->iter = 0
eval ii->n = ii->s->Len()
eval ii->c = 0;	// because End-Loop will check it
eval frame[s.v1].iter_info = ii

internal-op Next-String-Iter
type VVV
eval auto ii = frame[s.v1].iter_info
eval auto sval = ii->s
eval if ( ii->iter >= ii->n ) { pc = s.v3; break; }
eval auto bytes = (const char*) sval->Bytes() + ii->iter
eval auto sv = new StringVal(1, bytes)
### memory
eval frame[s.v2].string_val = new BroString(*sv->AsString())
eval delete sv
eval ++ii->iter

internal-op End-Loop
type V
eval auto ii = frame[s.v1].iter_info
eval if ( ii->c ) ii->loop_vals->StopIteration(ii->c)
eval delete ii


op When
type VVVV
eval auto when_body = new ResumptionAM(this, s.v2)
eval auto timeout_body = new ResumptionAM(this, s.v3)
eval new trigger::Trigger(s.non_const_e, when_body, timeout_body, frame[s.v1].double_val, f, s.v4, s.stmt->GetLocationInfo())

op When
type VVVC
eval auto when_body = new ResumptionAM(this, s.v2)
eval auto timeout_body = new ResumptionAM(this, s.v3)
eval new trigger::Trigger(s.non_const_e, when_body, timeout_body, s.c.double_val, f, s.v4, s.stmt->GetLocationInfo())

op When
type VV
eval auto when_body = new ResumptionAM(this, s.v2)
eval new trigger::Trigger(s.non_const_e, when_body, nullptr, -1.0, f, s.v4, s.stmt->GetLocationInfo())

op CheckAnyLen
type Vi
eval auto v = frame[s.v1].list_val
eval if ( v->Vals()->length() != s.v2 ) run_time_error(error_flag, s.stmt, "mismatch in list lengths")

op Print
type O
eval auto vvec = frame[s.v1].vvec
eval do_print(*vvec)
eval delete vvec
method-pre int reg = v->n; delete v


internal-op If-Else
type VV
eval if ( ! frame[s.v1].int_val ) pc = s.v2

internal-op If
type VV
eval if ( ! frame[s.v1].int_val ) pc = s.v2

internal-op If-Not
type VV
eval if ( frame[s.v1].int_val ) pc = s.v2


internal-op GoTo
type V
eval pc = s.v1


op AddStmt
type VO
eval auto vvec = frame[s.v2].vvec
eval auto lval = ValVecToListVal(vvec, vvec->size())
eval delete vvec
eval frame[s.v1].table_val->Assign(lval, nullptr)
eval delete lval
method-pre int reg = v->n; delete v


op DelTable
type VO
eval auto vvec = frame[s.v2].vvec
eval auto lval = ValVecToListVal(vvec, vvec->size())
eval delete vvec
eval frame[s.v1].table_val->Delete(lval)
eval delete lval
method-pre int reg = v->n; delete v

op DelField
type Vi
eval frame[s.v1].record_val->Assign(s.v2, nullptr)


internal-op Init-Record
type V
eval frame[s.v1].record_val = new RecordVal(s.t->AsRecordType())

internal-op Init-Vector
type V
eval frame[s.v1].vector_val = new VectorVal(s.t->AsVectorType())

internal-op Init-Table
type V
eval IntrusivePtr<TableType> tt = {NewRef{}, s.t->AsTableType()}
eval IntrusivePtr<Attributes> attrs = {NewRef{}, s.attrs}
eval frame[s.v1].table_val = new TableVal(tt, attrs)


########################################
# Internal
########################################

internal-op Load-Val
type VV
eval auto v = f->NthElement(s.v2)
eval if ( ! v ) reporter->InternalError("failure to load frame element");
eval frame[s.v1] = AS_ValUnion(v, s.t, v, error_flag)

internal-op Load-Global
type VC
eval frame[s.v1] = AS_ValUnion(s.c.id_val->ID_Val(), s.t, s.c.id_val, error_flag)

internal-op Store-Val
type VV
eval auto v = frame[s.v1].ToVal(s.t)
eval f->SetElement(s.v2, v.release())

internal-op Store-Global
type VC
### memory
eval IntrusivePtr<Val> v = frame[s.v1].ToVal(s.t)
eval s.c.id_val->SetVal(v)

# Initializes a new value vector.  We now do this dynamically, but at same
# point we could switch it to a static vector since we'll only have one of
# these at at time.
# 
# v1 is where to store the vector, v2 is its size (which we don't presently
# use).

internal-op Create-Val-Vec
type V
eval frame[s.v1].vvec = new val_vec

# Appends v2 to the vector pointed to by v1.
internal-op Set-Val-Vec
type VV
eval auto v = frame[s.v2].ToVal(s.t)
eval frame[s.v1].vvec->push_back(v)

# Appends c to the vector pointed to by v1.
internal-op Set-Val-Vec
type VC
eval auto c = s.c.ToVal(s.t)
eval frame[s.v1].vvec->push_back(c)

# Turns the vector at v2 (with v3 items) into a list_val at v1.  Deletes
# the original.
internal-op Transform-Val-Vec-To-List-Val
type VVV
eval frame[s.v1].list_val = ValVecToListVal(frame[s.v2].vvec, s.v3)

# Interprets the statement's expression as a stand-alone statement.
internal-op Interpret-Expr
type X
eval (void) s.e->Eval(f)

# Interprets the statement's expression and assigns the result to v1.
internal-op Interpret-Expr
type V
eval frame[s.v1] = AS_ValUnion(s.e->Eval(f).get(), s.t, s.e, error_flag)
