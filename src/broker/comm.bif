
##! Functions and events regarding Bro's broker communication mechanisms.

%%{
#include "broker/Manager.h"
%%}

module BrokerComm;

type BrokerComm::EndpointFlags: record;

function BrokerComm::__enable%(flags: EndpointFlags%): bool
	%{
	return new Val(broker_mgr->Enable(flags), TYPE_BOOL);
	%}

function BrokerComm::__set_endpoint_flags%(flags: EndpointFlags%): bool
	%{
	return new Val(broker_mgr->SetEndpointFlags(flags), TYPE_BOOL);
	%}

function BrokerComm::__publish_topic%(topic: string%): bool
	%{
	return new Val(broker_mgr->PublishTopic(topic->CheckString()), TYPE_BOOL);
	%}

function BrokerComm::__unpublish_topic%(topic: string%): bool
	%{
	return new Val(broker_mgr->UnpublishTopic(topic->CheckString()), TYPE_BOOL);
	%}

function BrokerComm::__advertise_topic%(topic: string%): bool
	%{
	return new Val(broker_mgr->AdvertiseTopic(topic->CheckString()), TYPE_BOOL);
	%}

function BrokerComm::__unadvertise_topic%(topic: string%): bool
	%{
	return new Val(broker_mgr->UnadvertiseTopic(topic->CheckString()), TYPE_BOOL);
	%}

## Generated when a connection has been established due to a previous call
## to :bro:see:`BrokerComm::connect`.
##
## peer_address: the address used to connect to the peer.
##
## peer_port: the port used to connect to the peer.
##
## peer_name: the name by which the peer identified itself.
event BrokerComm::outgoing_connection_established%(peer_address: string,
                                             peer_port: port,
                                             peer_name: string%);

## Generated when a previously established connection becomes broken.
## Reconnection will automatically be attempted at a frequency given
## by the original call to :bro:see:`BrokerComm::connect`.
##
## peer_address: the address used to connect to the peer.
##
## peer_port: the port used to connect to the peer.
##
## .. bro:see:: BrokerComm::outgoing_connection_established
event BrokerComm::outgoing_connection_broken%(peer_address: string,
                                        peer_port: port,
										peer_name: string%);

## Generated when a connection via :bro:see:`BrokerComm::connect` has failed
## because the remote side is incompatible.
##
## peer_address: the address used to connect to the peer.
##
## peer_port: the port used to connect to the peer.
event BrokerComm::outgoing_connection_incompatible%(peer_address: string,
                                            peer_port: port%);

## Generated when a peer has established a connection with this process
## as a result of previously performing a :bro:see:`BrokerComm::listen`.
##
## peer_name: the name by which the peer identified itself.
event BrokerComm::incoming_connection_established%(peer_name: string%);

## Generated when a peer that previously established a connection with this
## process becomes disconnected.
##
## peer_name: the name by which the peer identified itself.
##
## .. bro:see:: BrokerComm::incoming_connection_established
event BrokerComm::incoming_connection_broken%(peer_name: string%);

function BrokerComm::__listen%(p: port, a: string, reuse: bool%): bool
	%{
	if ( ! p->IsTCP() )
		{
		reporter->Error("listen port must use tcp");
		return new Val(false, TYPE_BOOL);
		}

	auto rval = broker_mgr->Listen(p->Port(), a->Len() ? a->CheckString() : 0,
								 reuse);
	return new Val(rval, TYPE_BOOL);
	%}

function BrokerComm::__connect%(a: string, p: port, retry: interval%): bool
	%{
	if ( ! p->IsTCP() )
		{
		reporter->Error("remote connection port must use tcp");
		return new Val(false, TYPE_BOOL);
		}

	auto rval = broker_mgr->Connect(a->CheckString(), p->Port(),
	                              std::chrono::duration<double>(retry));
	return new Val(rval, TYPE_BOOL);
	%}

function BrokerComm::__disconnect%(a: string, p: port%): bool
	%{
	if ( ! p->IsTCP() )
		{
		reporter->Error("remote connection port must use tcp");
		return new Val(false, TYPE_BOOL);
		}

	auto rval = broker_mgr->Disconnect(a->CheckString(), p->Port());
	return new Val(rval, TYPE_BOOL);
	%}
