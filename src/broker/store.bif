
##! Functions to interface with broker's distributed data store.

%%{
#include "broker/Manager.h"
#include "broker/Store.h"
#include "broker/Data.h"
#include "Trigger.h"
%%}

module Broker;

type Broker::QueryResult: record;

type Broker::BackendOptions: record;

## Enumerates the possible storage backends.
enum BackendType %{
	MEMORY,
	SQLITE,
	ROCKSDB,
%}

function Broker::__create_master%(id: string, b: BackendType,
                               options: BackendOptions &default = BackendOptions()%): opaque of Broker::Store
	%{
	auto name = id->CheckString();
	auto rval = broker_mgr->LookupStore(name);

	if ( rval )
		{
		::Ref(rval);
		return rval;
		}

	auto e = static_cast<BifEnum::Broker::BackendType>(b->AsEnum());
	auto type = bro_broker::to_backend_type(e);
	auto opts = bro_broker::to_backend_options(type, options->AsRecordVal());

	auto store = broker_mgr->MakeMaster(name, type, std::move(opts));
	if ( ! store )
		{
		reporter->Error("Could not create Broker master store '%s'", name);
		return nullptr;
		}

	return store;
	%}

function Broker::__create_clone%(id: string, resync_interval: interval%): opaque of Broker::Store
	%{
	auto name = id->CheckString();
	auto rval = broker_mgr->LookupStore(name);

	if ( rval )
		{
		::Ref(rval);
		return rval;
		}

	auto store = broker_mgr->MakeClone(name, resync_interval);
	if ( ! store )
		{
		reporter->Error("Could not create clone of Broker store '%s'", name);
		return nullptr;
		}

	return store;
	%}

function Broker::__is_closed%(h: opaque of Broker::Store%): bool
	%{
	if ( ! h )
		{
		reporter->Error("invalid Broker store handle");
		return new Val(false, TYPE_BOOL);
		}

	auto handle = static_cast<bro_broker::StoreHandleVal*>(h);
	return new Val(broker_mgr->LookupStore(handle->store.name()), TYPE_BOOL);
	%}

function Broker::__close%(h: opaque of Broker::Store%): bool
	%{
	if ( ! h )
		{
		reporter->Error("invalid Broker store handle");
		return new Val(false, TYPE_BOOL);
		}

	auto handle = static_cast<bro_broker::StoreHandleVal*>(h);
	return new Val(broker_mgr->CloseStore(handle->store.name()), TYPE_BOOL);
	%}

function Broker::__store_name%(h: opaque of Broker::Store%): string
	%{
	if ( ! h )
		{
		reporter->Error("invalid Broker store handle");
		return new StringVal("");
		}

	auto handle = static_cast<bro_broker::StoreHandleVal*>(h);
	return new StringVal(handle->store.name());
	%}

function Broker::__exists%(h: opaque of Broker::Store,
			   k: any%): Broker::QueryResult
	%{
	if ( ! h )
		{
		reporter->Error("invalid Broker store handle");
		return new Val(false, TYPE_BOOL);
		}

	auto handle = static_cast<bro_broker::StoreHandleVal*>(h);

	auto key = bro_broker::make_data_val(k)->Lookup(0);
	if ( ! key )
		return bro_broker::query_result();

	auto trigger = frame->GetTrigger();
	if ( ! trigger )
		{
		reporter->PushLocation(frame->GetCall()->GetLocationInfo());
		reporter->Error("Broker queries can only be called inside when-condition");
		reporter->PopLocation();
		return bro_broker::query_result();
		}

	auto timeout = trigger->TimeoutValue();
	if ( timeout < 0 )
		{
		reporter->PushLocation(frame->GetCall()->GetLocationInfo());
		reporter->Error("Broker queries must specify a timeout block");
		reporter->PopLocation();
		return bro_broker::query_result();
		}

	frame->SetDelayed();
	trigger->Hold();

	auto cb = new bro_broker::StoreQueryCallback(trigger, frame->GetCall(),
						     handle->store);
	auto req_id = handle->proxy.exists(static_cast<bro_broker::DataVal*>(key)->data);
	broker_mgr->TrackStoreQuery(req_id, cb);

	return 0;
	%}

function Broker::__get%(h: opaque of Broker::Store,
			k: any%): Broker::QueryResult
	%{
	if ( ! h )
		{
		reporter->Error("invalid Broker store handle");
		return new Val(false, TYPE_BOOL);
		}

	auto handle = static_cast<bro_broker::StoreHandleVal*>(h);

	auto key = bro_broker::make_data_val(k)->Lookup(0);
	if ( ! key )
		return bro_broker::query_result();

	auto trigger = frame->GetTrigger();
	if ( ! trigger )
		{
		reporter->PushLocation(frame->GetCall()->GetLocationInfo());
		reporter->Error("Broker queries can only be called inside when-condition");
		reporter->PopLocation();
		return bro_broker::query_result();
		}

	auto timeout = trigger->TimeoutValue();
	if ( timeout < 0 )
		{
		reporter->PushLocation(frame->GetCall()->GetLocationInfo());
		reporter->Error("Broker queries must specify a timeout block");
		reporter->PopLocation();
		return bro_broker::query_result();
		}

	frame->SetDelayed();
	trigger->Hold();

	auto cb = new bro_broker::StoreQueryCallback(trigger, frame->GetCall(),
                                               handle->store);
	auto req_id = handle->proxy.get(static_cast<bro_broker::DataVal*>(key)->data);
	broker_mgr->TrackStoreQuery(req_id, cb);

	return 0;
	%}

function Broker::__get_index_from_value%(h: opaque of Broker::Store,
					 k: any, i: any%): Broker::QueryResult
	%{
	if ( ! h )
		{
		reporter->Error("invalid Broker store handle");
		return new Val(false, TYPE_BOOL);
		}

	auto handle = static_cast<bro_broker::StoreHandleVal*>(h);

	auto key = bro_broker::make_data_val(k)->Lookup(0);
	if ( ! key )
		return bro_broker::query_result();

	auto index = bro_broker::make_data_val(i)->Lookup(0);
	if ( ! index )
		return bro_broker::query_result();
	
	auto trigger = frame->GetTrigger();
	if ( ! trigger )
		{
		reporter->PushLocation(frame->GetCall()->GetLocationInfo());
		reporter->Error("Broker queries can only be called inside when-condition");
		reporter->PopLocation();
		return bro_broker::query_result();
		}

	auto timeout = trigger->TimeoutValue();
	if ( timeout < 0 )
		{
		reporter->PushLocation(frame->GetCall()->GetLocationInfo());
		reporter->Error("Broker queries must specify a timeout block");
		reporter->PopLocation();
		return bro_broker::query_result();
		}

	frame->SetDelayed();
	trigger->Hold();

	auto cb = new bro_broker::StoreQueryCallback(trigger, frame->GetCall(),
						     handle->store);
	auto req_id = handle->proxy.get_index_from_value(static_cast<bro_broker::DataVal*>(key)->data,
							 static_cast<bro_broker::DataVal*>(index)->data);
	broker_mgr->TrackStoreQuery(req_id, cb);

	return 0;
	%}

function Broker::__keys%(h: opaque of Broker::Store%): Broker::QueryResult
	%{
	if ( ! h )
		{
		reporter->Error("invalid Broker store handle");
		return new Val(false, TYPE_BOOL);
		}

	auto handle = static_cast<bro_broker::StoreHandleVal*>(h);

	auto trigger = frame->GetTrigger();
	if ( ! trigger )
		{
		reporter->PushLocation(frame->GetCall()->GetLocationInfo());
		reporter->Error("Broker queries can only be called inside when-condition");
		reporter->PopLocation();
		return bro_broker::query_result();
		}

	auto timeout = trigger->TimeoutValue();
	if ( timeout < 0 )
		{
		reporter->PushLocation(frame->GetCall()->GetLocationInfo());
		reporter->Error("Broker queries must specify a timeout block");
		reporter->PopLocation();
		return bro_broker::query_result();
		}

	frame->SetDelayed();
	trigger->Hold();

	auto cb = new bro_broker::StoreQueryCallback(trigger, frame->GetCall(),
						     handle->store);
	auto req_id = handle->proxy.keys();
	broker_mgr->TrackStoreQuery(req_id, cb);

	return 0;
	%}

function Broker::__put%(h: opaque of Broker::Store,
                        k: any, v: any, e: interval%): bool
	%{
	if ( ! h )
		{
		reporter->Error("invalid Broker store handle");
		return new Val(false, TYPE_BOOL);
		}

	auto handle = static_cast<bro_broker::StoreHandleVal*>(h);

	auto& key = bro_broker::opaque_field_to_data(bro_broker::make_data_val(k), frame);
	auto& val = bro_broker::opaque_field_to_data(bro_broker::make_data_val(v), frame);

	broker::optional<broker::timespan> ts;
	if ( ts )
		{
		broker::timespan x;
		broker::convert(e, x);
		ts = x;
		}

	handle->store.put(key, val, ts);
	return new Val(true, TYPE_BOOL);
	%}

function Broker::__erase%(h: opaque of Broker::Store, k: any%): bool
	%{
	if ( ! h )
		{
		reporter->Error("invalid Broker store handle");
		return new Val(false, TYPE_BOOL);
		}

	auto handle = static_cast<bro_broker::StoreHandleVal*>(h);

	auto& key = bro_broker::opaque_field_to_data(bro_broker::make_data_val(k), frame);
	handle->store.erase(key);
	return new Val(true, TYPE_BOOL);
	%}

%%{
static bro_broker::StoreHandleVal* prepare_store_handle(Val* h)
	{
	if ( ! h )
		{
		reporter->Error("invalid Broker store handle");
		return nullptr;
		}

	return static_cast<bro_broker::StoreHandleVal*>(h);
	}

static broker::optional<broker::timespan> prepare_expiry(double e)
	{
	broker::optional<broker::timespan> ts;

	if ( e ) 
		{
		broker::timespan x;
		broker::convert(e, x);
		ts = x;
		}

	return ts;
	}
%%}

function Broker::__increment%(h: opaque of Broker::Store, k: any, a: any, e: interval%): bool
	%{
	auto handle = prepare_store_handle(h);

	if ( ! handle )
		return new Val(false, TYPE_BOOL);

	auto& key = bro_broker::opaque_field_to_data(bro_broker::make_data_val(k), frame);
	auto& amount = bro_broker::opaque_field_to_data(bro_broker::make_data_val(a), frame);
	auto expiry = prepare_expiry(e);
	handle->store.increment(key, amount, expiry);
	return new Val(true, TYPE_BOOL);
	%}

function Broker::__decrement%(h: opaque of Broker::Store, k: any, a: any, e: interval%): bool
	%{
	auto handle = prepare_store_handle(h);

	if ( ! handle )
		return new Val(false, TYPE_BOOL);

	auto& key = bro_broker::opaque_field_to_data(bro_broker::make_data_val(k), frame);
	auto& amount = bro_broker::opaque_field_to_data(bro_broker::make_data_val(a), frame);
	auto expiry = prepare_expiry(e);
	handle->store.decrement(key, amount, expiry);
	return new Val(true, TYPE_BOOL);
	%}

function Broker::__append%(h: opaque of Broker::Store, k: any, s: any, e: interval%): bool
	%{
	auto handle = prepare_store_handle(h);

	if ( ! handle )
		return new Val(false, TYPE_BOOL);

	auto& key = bro_broker::opaque_field_to_data(bro_broker::make_data_val(k), frame);
	auto& str = bro_broker::opaque_field_to_data(bro_broker::make_data_val(s), frame);
	auto expiry = prepare_expiry(e);
	handle->store.append(key, str, expiry);
	return new Val(true, TYPE_BOOL);
	%}

function Broker::__insert_into_set%(h: opaque of Broker::Store, k: any, i: any, e: interval%): bool
	%{
	auto handle = prepare_store_handle(h);

	if ( ! handle )
		return new Val(false, TYPE_BOOL);

	auto& key = bro_broker::opaque_field_to_data(bro_broker::make_data_val(k), frame);
	auto& idx = bro_broker::opaque_field_to_data(bro_broker::make_data_val(i), frame);
	auto expiry = prepare_expiry(e);
	handle->store.insert_into(key, idx, expiry);
	return new Val(true, TYPE_BOOL);
	%}

function Broker::__insert_into_table%(h: opaque of Broker::Store, k: any, i: any, v: any, e: interval%): bool
	%{
	auto handle = prepare_store_handle(h);

	if ( ! handle )
		return new Val(false, TYPE_BOOL);

	auto& key = bro_broker::opaque_field_to_data(bro_broker::make_data_val(k), frame);
	auto& idx = bro_broker::opaque_field_to_data(bro_broker::make_data_val(i), frame);
	auto& val = bro_broker::opaque_field_to_data(bro_broker::make_data_val(v), frame);
	auto expiry = prepare_expiry(e);
	handle->store.insert_into(key, idx, val, expiry);
	return new Val(true, TYPE_BOOL);
	%}

function Broker::__remove_from%(h: opaque of Broker::Store, k: any, i: any, e: interval%): bool
	%{
	auto handle = prepare_store_handle(h);

	if ( ! handle )
		return new Val(false, TYPE_BOOL);

	auto& key = bro_broker::opaque_field_to_data(bro_broker::make_data_val(k), frame);
	auto& idx = bro_broker::opaque_field_to_data(bro_broker::make_data_val(i), frame);
	auto expiry = prepare_expiry(e);
	handle->store.remove_from(key, idx, expiry);
	return new Val(true, TYPE_BOOL);
	%}

function Broker::__push%(h: opaque of Broker::Store, k: any, v: any, e: interval%): bool
	%{
	auto handle = prepare_store_handle(h);

	if ( ! handle )
		return new Val(false, TYPE_BOOL);

	auto& key = bro_broker::opaque_field_to_data(bro_broker::make_data_val(k), frame);
	auto& val = bro_broker::opaque_field_to_data(bro_broker::make_data_val(v), frame);
	auto expiry = prepare_expiry(e);
	handle->store.push(key, val, expiry);
	return new Val(true, TYPE_BOOL);
	%}

function Broker::__pop%(h: opaque of Broker::Store, k: any, e: interval%): bool
	%{
	auto handle = prepare_store_handle(h);

	if ( ! handle )
		return new Val(false, TYPE_BOOL);

	auto& key = bro_broker::opaque_field_to_data(bro_broker::make_data_val(k), frame);
	auto expiry = prepare_expiry(e);
	handle->store.pop(key, expiry);
	return new Val(true, TYPE_BOOL);
	%}

function Broker::__clear%(h: opaque of Broker::Store%): bool
	%{
	if ( ! h )
		{
		reporter->Error("invalid Broker store handle");
		return new Val(false, TYPE_BOOL);
		}

	auto handle = static_cast<bro_broker::StoreHandleVal*>(h);

	handle->store.clear();
	return new Val(true, TYPE_BOOL);
	%}
