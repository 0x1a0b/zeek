
##! Functions for peering and various messaging patterns.

%%{
#include "broker/Manager.h"
#include "logging/Manager.h"
%%}

module Broker;

type Broker::Event: record;

## Create a data structure that may be used to send a remote event via
## :bro:see:`Broker::publish`.
##
## args: an event, followed by a list of argument values that may be used
##       to call it.
##
## Returns: opaque communication data that may be used to send a remote
##          event.
function Broker::make_event%(...%): Broker::Event
	%{
	auto rval = broker_mgr->MakeEvent(@ARGS@);
	return rval;
	%}

function Broker::__publish%(topic: string, ev: Broker::Event%): bool
	%{
	auto rval = broker_mgr->PublishEvent(topic->CheckString(), ev->AsRecordVal());
	return new Val(rval, TYPE_BOOL);
	%}

function Broker::__publish_id%(topic: string, id: string%): bool
	%{
	auto rval = broker_mgr->PublishIdentifier(topic->CheckString(),
	                                          id->CheckString());
	return new Val(rval, TYPE_BOOL);
	%}

function Broker::__auto_publish%(topic: string, ev: any%): bool
	%{
	auto rval = broker_mgr->AutoPublishEvent(topic->CheckString(), ev);
	return new Val(rval, TYPE_BOOL);
	%}

function Broker::__auto_unpublish%(topic: string, ev: any%): bool
	%{
	auto rval = broker_mgr->AutoUnpublishEvent(topic->CheckString(), ev);
	return new Val(rval, TYPE_BOOL);
	%}

function Broker::__subscribe%(topic_prefix: string%): bool
	%{
	auto rval = broker_mgr->Subscribe(topic_prefix->CheckString());
	return new Val(rval, TYPE_BOOL);
	%}

function Broker::__unsubscribe%(topic_prefix: string%): bool
	%{
	auto rval = broker_mgr->Unsubscribe(topic_prefix->CheckString());
	return new Val(rval, TYPE_BOOL);
	%}

module Cluster;

type Cluster::Pool: record;

function Cluster::publish_rr%(pool: Pool, key: string, ...%): bool
	%{
	static Func* topic_func = 0;

	if ( ! topic_func )
		topic_func = global_scope()->Lookup("Cluster::rr_topic")->ID_Val()->AsFunc();

	val_list vl(2);
	vl.append(pool->Ref());
	vl.append(key->Ref());
	auto topic = topic_func->Call(&vl);

	if ( ! topic->AsString()->Len() )
		{
		Unref(topic);
		return new Val(false, TYPE_BOOL);
		}

	val_list* bif_args = @ARGS@;
	val_list args(bif_args->length() - 2);

	for ( auto i = 2u; i < bif_args->length(); ++i )
		args.append((*bif_args)[i]);

	auto ev = broker_mgr->MakeEvent(&args);

	if ( ! ev->Lookup(0) )
		{
		Unref(topic);
		Unref(ev);
		return new Val(false, TYPE_BOOL);
		}

	auto rval = broker_mgr->PublishEvent(topic->AsString()->CheckString(),
										 ev->AsRecordVal());
	Unref(topic);
	Unref(ev);
	return new Val(rval, TYPE_BOOL);
	%}

function Cluster::publish_hrw%(pool: Pool, key: any, ...%): bool
	%{
	static Func* topic_func = 0;

	if ( ! topic_func )
		topic_func = global_scope()->Lookup("Cluster::hrw_topic")->ID_Val()->AsFunc();

	val_list vl(2);
	vl.append(pool->Ref());
	vl.append(key->Ref());
	auto topic = topic_func->Call(&vl);

	if ( ! topic->AsString()->Len() )
		{
		Unref(topic);
		return new Val(false, TYPE_BOOL);
		}

	val_list* bif_args = @ARGS@;
	val_list args(bif_args->length() - 2);

	for ( auto i = 2u; i < bif_args->length(); ++i )
		args.append((*bif_args)[i]);

	auto ev = broker_mgr->MakeEvent(&args);

	if ( ! ev->Lookup(0) )
		{
		Unref(topic);
		Unref(ev);
		return new Val(false, TYPE_BOOL);
		}

	auto rval = broker_mgr->PublishEvent(topic->AsString()->CheckString(),
										 ev->AsRecordVal());
	Unref(topic);
	Unref(ev);
	return new Val(rval, TYPE_BOOL);
	%}
