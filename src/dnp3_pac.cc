// This file is automatically generated from dnp3.pac.

#include "dnp3_pac.h"

namespace binpac {






namespace Dnp3 {
ContextDnp3::ContextDnp3(Dnp3_Conn * connection, Dnp3_Flow * flow)
	{
	connection_ = connection;
	flow_ = flow;
	}

ContextDnp3::~ContextDnp3()
	{
	}

Dnp3_PDU::Dnp3_PDU(bool is_orig)
	{
	val_case_index_ = -1;
	request_ = 0;
	response_ = 0;
	is_orig_ = is_orig;
	byteorder_ = bigendian;
	}

Dnp3_PDU::~Dnp3_PDU()
	{
	switch ( val_case_index() )
		{
		case 1:
			// Clean up "request"
			{
			delete request_;
			request_ = 0;
			}
			break;
		case 0:
			// Clean up "response"
			{
			delete response_;
			response_ = 0;
			}
			break;
		}
	}

int Dnp3_PDU::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data)
	{
	int t_val__size;
	val_case_index_ = is_orig();
	switch ( val_case_index() )
		{
		case 1:
			// Parse "request"
			{
			request_ = new Dnp3_Request();
			int t_request__size;
			t_request__size = request_->Parse(t_begin_of_data, t_end_of_data, byteorder());
			// Evaluate 'let' and 'withinput' fields
			t_val__size = t_request__size;
			}
			break;
		case 0:
			// Parse "response"
			{
			response_ = new Dnp3_Response();
			int t_response__size;
			t_response__size = response_->Parse(t_begin_of_data, t_end_of_data);
			// Evaluate 'let' and 'withinput' fields
			t_val__size = t_response__size;
			}
			break;
		default:
			throw ExceptionInvalidCaseIndex("Dnp3_PDU", val_case_index());
			break;
		}
	// Evaluate 'let' and 'withinput' fields
	BINPAC_ASSERT(t_begin_of_data + (t_val__size) <= t_end_of_data);
	return t_val__size;
	}

Dnp3_Request::Dnp3_Request()
	{
	app_header_ = 0;
	data_case_index_ = -1;
	objects_ = 0;
	objects__elem_ = 0;
	}

Dnp3_Request::~Dnp3_Request()
	{
	delete app_header_;
	app_header_ = 0;
	switch ( data_case_index() )
		{
		case 0:
			// Clean up "none_coonfirm"
			{
			}
			break;
		case 1:
			// Clean up "objects"
			{
			delete objects__elem_;
			objects__elem_ = 0;
			if ( objects() )
				{
				for ( int i = 0; i < (int) objects()->size(); ++i )
					{
					Request_Objects * objects__elem_ = (*objects_)[i];
					delete objects__elem_;
					objects__elem_ = 0;
					}
				}
			delete objects_;
			}
			break;
		default:
			// Clean up "unknown"
			{
			unknown_.free();
			}
			break;
		}
	}

int Dnp3_Request::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, int t_byteorder)
	{
	// Checking out-of-bound for "Dnp3_Request:app_header"
	if ( t_begin_of_data + (2) > t_end_of_data )
		{
		// Handle out-of-bound condition
		throw ExceptionOutOfBound("Dnp3_Request:app_header",
			(0) + (2), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "app_header"
	app_header_ = new Dnp3_Application_Request_Header();
	app_header_->Parse(t_begin_of_data, t_end_of_data);
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "data"
	int t_data__size;
	data_case_index_ = app_header()->function_code();
	switch ( data_case_index() )
		{
		case 0:
			// Parse "none_coonfirm"
			{
			// Evaluate 'let' and 'withinput' fields
			t_data__size = 0;
			}
			break;
		case 1:
			// Parse "objects"
			{
			int t_objects__arraylength;
			objects__elem_ = 0;
			int t_objects__elem__it;
			t_objects__elem__it = 0;
			int t_objects__size;
			objects_ = new vector<Request_Objects *>;
			const_byteptr t_objects__elem__dataptr = (t_begin_of_data + 2);
			for (; /* forever */; ++t_objects__elem__it)
				{
				// Check &until(objects__elem__dataptr >= end_of_data)
				if ( t_objects__elem__dataptr >= t_end_of_data )
					{
					objects__elem_ = 0;
					goto end_of_objects;
					}
				objects__elem_ = new Request_Objects();
				int t_objects__elem__size;
				t_objects__elem__size = objects__elem_->Parse(t_objects__elem__dataptr, t_end_of_data, t_byteorder);
				// Evaluate 'let' and 'withinput' fields
				objects_->push_back(objects__elem_);
				t_objects__elem__dataptr += t_objects__elem__size;
				BINPAC_ASSERT(t_objects__elem__dataptr <= t_end_of_data);
				objects__elem_ = 0;
				}
		end_of_objects: ;
			t_objects__size = t_objects__elem__dataptr - ((t_begin_of_data + 2));
			// Evaluate 'let' and 'withinput' fields
			t_data__size = t_objects__size;
			}
			break;
		default:
			// Parse "unknown"
			{
			int t_unknown_string_length;
			t_unknown_string_length = (t_end_of_data) - ((t_begin_of_data + 2));
			int t_unknown__size;
			t_unknown__size = t_unknown_string_length;
			// check for negative sizes
			if ( t_unknown_string_length < 0 )
			throw ExceptionInvalidStringLength("./dnp3-protocol.pac:15", t_unknown_string_length);
			unknown_.init((t_begin_of_data + 2), t_unknown_string_length);
			// Evaluate 'let' and 'withinput' fields
			t_data__size = t_unknown__size;
			}
			break;
		}
	// Evaluate 'let' and 'withinput' fields
	
	int t_Dnp3_Request__size;
	const_byteptr const t_dataptr_after_data = (t_begin_of_data + 2) + (t_data__size);
	BINPAC_ASSERT(t_dataptr_after_data <= t_end_of_data);
	t_Dnp3_Request__size = t_dataptr_after_data - t_begin_of_data;
	// Evaluate 'let' and 'withinput' fields
	BINPAC_ASSERT(t_begin_of_data + (t_Dnp3_Request__size) <= t_end_of_data);
	return t_Dnp3_Request__size;
	}

Dnp3_Response::Dnp3_Response()
	{
	app_header_ = 0;
	data_case_index_ = -1;
	}

Dnp3_Response::~Dnp3_Response()
	{
	delete app_header_;
	app_header_ = 0;
	switch ( data_case_index() )
		{
		default:
			// Clean up "unknown"
			{
			unknown_.free();
			}
			break;
		}
	}

int Dnp3_Response::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data)
	{
	// Checking out-of-bound for "Dnp3_Response:app_header"
	if ( t_begin_of_data + (4) > t_end_of_data )
		{
		// Handle out-of-bound condition
		throw ExceptionOutOfBound("Dnp3_Response:app_header",
			(0) + (4), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "app_header"
	app_header_ = new Dnp3_Application_Response_Header();
	app_header_->Parse(t_begin_of_data, t_end_of_data);
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "data"
	int t_data__size;
	data_case_index_ = app_header()->function_code();
	switch ( data_case_index() )
		{
		default:
			// Parse "unknown"
			{
			int t_unknown_string_length;
			t_unknown_string_length = (t_end_of_data) - ((t_begin_of_data + 4));
			int t_unknown__size;
			t_unknown__size = t_unknown_string_length;
			// check for negative sizes
			if ( t_unknown_string_length < 0 )
			throw ExceptionInvalidStringLength("./dnp3-protocol.pac:23", t_unknown_string_length);
			unknown_.init((t_begin_of_data + 4), t_unknown_string_length);
			// Evaluate 'let' and 'withinput' fields
			t_data__size = t_unknown__size;
			}
			break;
		}
	// Evaluate 'let' and 'withinput' fields
	
	int t_Dnp3_Response__size;
	const_byteptr const t_dataptr_after_data = (t_begin_of_data + 4) + (t_data__size);
	BINPAC_ASSERT(t_dataptr_after_data <= t_end_of_data);
	t_Dnp3_Response__size = t_dataptr_after_data - t_begin_of_data;
	// Evaluate 'let' and 'withinput' fields
	BINPAC_ASSERT(t_begin_of_data + (t_Dnp3_Response__size) <= t_end_of_data);
	return t_Dnp3_Response__size;
	}

Dnp3_Application_Request_Header::Dnp3_Application_Request_Header()
	{
	application_control_ = 0;
	function_code_ = 0;
	}

Dnp3_Application_Request_Header::~Dnp3_Application_Request_Header()
	{
	}

int Dnp3_Application_Request_Header::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data)
	{
	// Checking out-of-bound for "Dnp3_Application_Request_Header"
	if ( t_begin_of_data + (2) > t_end_of_data )
		{
		// Handle out-of-bound condition
		throw ExceptionOutOfBound("Dnp3_Application_Request_Header",
			(0) + (2), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "application_control"
	application_control_ = *((uint8 const *) (t_begin_of_data));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "function_code"
	function_code_ = *((uint8 const *) ((t_begin_of_data + 1)));
	// Evaluate 'let' and 'withinput' fields
	
	// Evaluate 'let' and 'withinput' fields
	BINPAC_ASSERT(t_begin_of_data + (2) <= t_end_of_data);
	return 2;
	}

Dnp3_Application_Response_Header::Dnp3_Application_Response_Header()
	{
	application_control_ = 0;
	function_code_ = 0;
	internal_indications_ = 0;
	}

Dnp3_Application_Response_Header::~Dnp3_Application_Response_Header()
	{
	delete internal_indications_;
	internal_indications_ = 0;
	}

int Dnp3_Application_Response_Header::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data)
	{
	// Checking out-of-bound for "Dnp3_Application_Response_Header"
	if ( t_begin_of_data + (4) > t_end_of_data )
		{
		// Handle out-of-bound condition
		throw ExceptionOutOfBound("Dnp3_Application_Response_Header",
			(0) + (4), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "application_control"
	application_control_ = *((uint8 const *) (t_begin_of_data));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "function_code"
	function_code_ = *((uint8 const *) ((t_begin_of_data + 1)));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "internal_indications"
	internal_indications_ = new Response_Internal_Indication();
	internal_indications_->Parse((t_begin_of_data + 2), t_end_of_data);
	// Evaluate 'let' and 'withinput' fields
	
	// Evaluate 'let' and 'withinput' fields
	BINPAC_ASSERT(t_begin_of_data + (4) <= t_end_of_data);
	return 4;
	}

Response_Internal_Indication::Response_Internal_Indication()
	{
	first_octet_ = 0;
	second_octet_ = 0;
	}

Response_Internal_Indication::~Response_Internal_Indication()
	{
	}

int Response_Internal_Indication::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data)
	{
	// Checking out-of-bound for "Response_Internal_Indication"
	if ( t_begin_of_data + (2) > t_end_of_data )
		{
		// Handle out-of-bound condition
		throw ExceptionOutOfBound("Response_Internal_Indication",
			(0) + (2), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "first_octet"
	first_octet_ = *((uint8 const *) (t_begin_of_data));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "second_octet"
	second_octet_ = *((uint8 const *) ((t_begin_of_data + 1)));
	// Evaluate 'let' and 'withinput' fields
	
	// Evaluate 'let' and 'withinput' fields
	BINPAC_ASSERT(t_begin_of_data + (2) <= t_end_of_data);
	return 2;
	}

Request_Objects::Request_Objects()
	{
	object_header_ = 0;
	data_case_index_ = -1;
	}

Request_Objects::~Request_Objects()
	{
	delete object_header_;
	object_header_ = 0;
	switch ( data_case_index() )
		{
		case 8193:
			// Clean up "ai32wotime"
			{
			}
			break;
		case 8194:
			// Clean up "ai16wotime"
			{
			}
			break;
		case 8195:
			// Clean up "ai32wtime"
			{
			}
			break;
		case 8196:
			// Clean up "ai16wtime"
			{
			}
			break;
		case 8197:
			// Clean up "aispwotime"
			{
			}
			break;
		case 8198:
			// Clean up "aidpwotime"
			{
			}
			break;
		case 8199:
			// Clean up "aispwtime"
			{
			}
			break;
		case 8200:
			// Clean up "aidpwtime"
			{
			}
			break;
		case 15361:
			// Clean up "class0data"
			{
			}
			break;
		case 15362:
			// Clean up "class1data"
			{
			}
			break;
		case 15363:
			// Clean up "class2data"
			{
			}
			break;
		case 15364:
			// Clean up "class3data"
			{
			}
			break;
		default:
			// Clean up "unknown"
			{
			unknown_.free();
			}
			break;
		}
	}

int Request_Objects::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, int t_byteorder)
	{
	// Parse "object_header"
	object_header_ = new Object_Header();
	int t_object_header__size;
	t_object_header__size = object_header_->Parse(t_begin_of_data, t_end_of_data, t_byteorder);
	// Evaluate 'let' and 'withinput' fields
	
	const_byteptr const t_dataptr_after_object_header = t_begin_of_data + (t_object_header__size);
	BINPAC_ASSERT(t_dataptr_after_object_header <= t_end_of_data);
	// Parse "data"
	int t_data__size;
	data_case_index_ =  ( object_header()->object_type_field() ) ;
	switch ( data_case_index() )
		{
		case 8193:
			// Parse "ai32wotime"
			{
			// Evaluate 'let' and 'withinput' fields
			t_data__size = 0;
			}
			break;
		case 8194:
			// Parse "ai16wotime"
			{
			// Evaluate 'let' and 'withinput' fields
			t_data__size = 0;
			}
			break;
		case 8195:
			// Parse "ai32wtime"
			{
			// Evaluate 'let' and 'withinput' fields
			t_data__size = 0;
			}
			break;
		case 8196:
			// Parse "ai16wtime"
			{
			// Evaluate 'let' and 'withinput' fields
			t_data__size = 0;
			}
			break;
		case 8197:
			// Parse "aispwotime"
			{
			// Evaluate 'let' and 'withinput' fields
			t_data__size = 0;
			}
			break;
		case 8198:
			// Parse "aidpwotime"
			{
			// Evaluate 'let' and 'withinput' fields
			t_data__size = 0;
			}
			break;
		case 8199:
			// Parse "aispwtime"
			{
			// Evaluate 'let' and 'withinput' fields
			t_data__size = 0;
			}
			break;
		case 8200:
			// Parse "aidpwtime"
			{
			// Evaluate 'let' and 'withinput' fields
			t_data__size = 0;
			}
			break;
		case 15361:
			// Parse "class0data"
			{
			// Evaluate 'let' and 'withinput' fields
			t_data__size = 0;
			}
			break;
		case 15362:
			// Parse "class1data"
			{
			// Evaluate 'let' and 'withinput' fields
			t_data__size = 0;
			}
			break;
		case 15363:
			// Parse "class2data"
			{
			// Evaluate 'let' and 'withinput' fields
			t_data__size = 0;
			}
			break;
		case 15364:
			// Parse "class3data"
			{
			// Evaluate 'let' and 'withinput' fields
			t_data__size = 0;
			}
			break;
		default:
			// Parse "unknown"
			{
			int t_unknown_string_length;
			t_unknown_string_length = (t_end_of_data) - (t_dataptr_after_object_header);
			int t_unknown__size;
			t_unknown__size = t_unknown_string_length;
			// check for negative sizes
			if ( t_unknown_string_length < 0 )
			throw ExceptionInvalidStringLength("./dnp3-protocol.pac:63", t_unknown_string_length);
			unknown_.init(t_dataptr_after_object_header, t_unknown_string_length);
			// Evaluate 'let' and 'withinput' fields
			t_data__size = t_unknown__size;
			}
			break;
		}
	// Evaluate 'let' and 'withinput' fields
	
	int t_Request_Objects__size;
	const_byteptr const t_dataptr_after_data = t_dataptr_after_object_header + (t_data__size);
	BINPAC_ASSERT(t_dataptr_after_data <= t_end_of_data);
	t_Request_Objects__size = t_dataptr_after_data - t_begin_of_data;
	// Evaluate 'let' and 'withinput' fields
	BINPAC_ASSERT(t_begin_of_data + (t_Request_Objects__size) <= t_end_of_data);
	return t_Request_Objects__size;
	}

Response_Objects::Response_Objects()
	{
	object_header_ = 0;
	data_case_index_ = -1;
	ai32wotime_ = 0;
	ai32wotime__elem_ = 0;
	ai16wotime_ = 0;
	ai32wtime_ = 0;
	ai16wtime_ = 0;
	aispwotime_ = 0;
	aidpwotime_ = 0;
	aispwtime_ = 0;
	aidpwtime_ = 0;
	}

Response_Objects::~Response_Objects()
	{
	delete object_header_;
	object_header_ = 0;
	switch ( data_case_index() )
		{
		case 8193:
			// Clean up "ai32wotime"
			{
			delete ai32wotime__elem_;
			ai32wotime__elem_ = 0;
			if ( ai32wotime() )
				{
				for ( int i = 0; i < (int) ai32wotime()->size(); ++i )
					{
					AnalogInput32woTime * ai32wotime__elem_ = (*ai32wotime_)[i];
					delete ai32wotime__elem_;
					ai32wotime__elem_ = 0;
					}
				}
			delete ai32wotime_;
			}
			break;
		case 8194:
			// Clean up "ai16wotime"
			{
			delete ai16wotime_;
			ai16wotime_ = 0;
			}
			break;
		case 8195:
			// Clean up "ai32wtime"
			{
			delete ai32wtime_;
			ai32wtime_ = 0;
			}
			break;
		case 8196:
			// Clean up "ai16wtime"
			{
			delete ai16wtime_;
			ai16wtime_ = 0;
			}
			break;
		case 8197:
			// Clean up "aispwotime"
			{
			delete aispwotime_;
			aispwotime_ = 0;
			}
			break;
		case 8198:
			// Clean up "aidpwotime"
			{
			delete aidpwotime_;
			aidpwotime_ = 0;
			}
			break;
		case 8199:
			// Clean up "aispwtime"
			{
			delete aispwtime_;
			aispwtime_ = 0;
			}
			break;
		case 8200:
			// Clean up "aidpwtime"
			{
			delete aidpwtime_;
			aidpwtime_ = 0;
			}
			break;
		}
	}

int Response_Objects::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, int t_byteorder)
	{
	// Parse "object_header"
	object_header_ = new Object_Header();
	int t_object_header__size;
	t_object_header__size = object_header_->Parse(t_begin_of_data, t_end_of_data, t_byteorder);
	// Evaluate 'let' and 'withinput' fields
	
	const_byteptr const t_dataptr_after_object_header = t_begin_of_data + (t_object_header__size);
	BINPAC_ASSERT(t_dataptr_after_object_header <= t_end_of_data);
	// Parse "data"
	int t_data__size;
	data_case_index_ =  ( object_header()->object_type_field() ) ;
	switch ( data_case_index() )
		{
		case 8193:
			// Parse "ai32wotime"
			{
			int t_ai32wotime__arraylength;
			t_ai32wotime__arraylength = object_header()->number_of_item();
			if ( t_begin_of_data + t_ai32wotime__arraylength > t_end_of_data + 1 )
				{
				t_ai32wotime__arraylength = t_end_of_data - t_begin_of_data + 1;
				}
			if ( t_ai32wotime__arraylength < 0 )
				{
				t_ai32wotime__arraylength = 0;
				}
			ai32wotime__elem_ = 0;
			int t_ai32wotime__elem__it;
			t_ai32wotime__elem__it = 0;
			int t_ai32wotime__size;
			ai32wotime_ = new vector<AnalogInput32woTime *>;
			ai32wotime_->reserve(t_ai32wotime__arraylength);
			const_byteptr t_ai32wotime__elem__dataptr = t_dataptr_after_object_header;
			for (; t_ai32wotime__elem__it < t_ai32wotime__arraylength; ++t_ai32wotime__elem__it)
				{
				// Check &until(ai32wotime__elem__dataptr >= end_of_data)
				if ( t_ai32wotime__elem__dataptr >= t_end_of_data )
					{
					ai32wotime__elem_ = 0;
					goto end_of_ai32wotime;
					}
				ai32wotime__elem_ = new AnalogInput32woTime();
				ai32wotime__elem_->Parse(t_ai32wotime__elem__dataptr, t_end_of_data, t_byteorder);
				// Evaluate 'let' and 'withinput' fields
				ai32wotime_->push_back(ai32wotime__elem_);
				t_ai32wotime__elem__dataptr += 5;
				BINPAC_ASSERT(t_ai32wotime__elem__dataptr <= t_end_of_data);
				ai32wotime__elem_ = 0;
				}
		end_of_ai32wotime: ;
			t_ai32wotime__size = t_ai32wotime__elem__dataptr - (t_dataptr_after_object_header);
			// Evaluate 'let' and 'withinput' fields
			t_data__size = t_ai32wotime__size;
			}
			break;
		case 8194:
			// Parse "ai16wotime"
			{
			ai16wotime_ = new AnalogInput16woTime();
			ai16wotime_->Parse(t_dataptr_after_object_header, t_end_of_data, t_byteorder);
			// Evaluate 'let' and 'withinput' fields
			t_data__size = 3;
			}
			break;
		case 8195:
			// Parse "ai32wtime"
			{
			ai32wtime_ = new AnalogInput32wTime();
			ai32wtime_->Parse(t_dataptr_after_object_header, t_end_of_data, t_byteorder);
			// Evaluate 'let' and 'withinput' fields
			t_data__size = 11;
			}
			break;
		case 8196:
			// Parse "ai16wtime"
			{
			ai16wtime_ = new AnalogInput16wTime();
			ai16wtime_->Parse(t_dataptr_after_object_header, t_end_of_data, t_byteorder);
			// Evaluate 'let' and 'withinput' fields
			t_data__size = 9;
			}
			break;
		case 8197:
			// Parse "aispwotime"
			{
			aispwotime_ = new AnalogInputSPwoTime();
			aispwotime_->Parse(t_dataptr_after_object_header, t_end_of_data, t_byteorder);
			// Evaluate 'let' and 'withinput' fields
			t_data__size = 5;
			}
			break;
		case 8198:
			// Parse "aidpwotime"
			{
			aidpwotime_ = new AnalogInputDPwoTime();
			aidpwotime_->Parse(t_dataptr_after_object_header, t_end_of_data, t_byteorder);
			// Evaluate 'let' and 'withinput' fields
			t_data__size = 9;
			}
			break;
		case 8199:
			// Parse "aispwtime"
			{
			aispwtime_ = new AnalogInputSPwTime();
			aispwtime_->Parse(t_dataptr_after_object_header, t_end_of_data, t_byteorder);
			// Evaluate 'let' and 'withinput' fields
			t_data__size = 11;
			}
			break;
		case 8200:
			// Parse "aidpwtime"
			{
			aidpwtime_ = new AnalogInputDPwTime();
			aidpwtime_->Parse(t_dataptr_after_object_header, t_end_of_data, t_byteorder);
			// Evaluate 'let' and 'withinput' fields
			t_data__size = 15;
			}
			break;
		default:
			throw ExceptionInvalidCaseIndex("Response_Objects", data_case_index());
			break;
		}
	// Evaluate 'let' and 'withinput' fields
	
	int t_Response_Objects__size;
	const_byteptr const t_dataptr_after_data = t_dataptr_after_object_header + (t_data__size);
	BINPAC_ASSERT(t_dataptr_after_data <= t_end_of_data);
	t_Response_Objects__size = t_dataptr_after_data - t_begin_of_data;
	// Evaluate 'let' and 'withinput' fields
	BINPAC_ASSERT(t_begin_of_data + (t_Response_Objects__size) <= t_end_of_data);
	return t_Response_Objects__size;
	}

Object_Header::Object_Header()
	{
	object_type_field_ = 0;
	qualifier_field_ = 0;
	range_field_case_index_ = -1;
	range_field_0_ = 0;
	range_field_1_ = 0;
	range_field_2_ = 0;
	range_field_3_ = 0;
	range_field_4_ = 0;
	range_field_5_ = 0;
	range_field_7_ = 0;
	range_field_8_ = 0;
	range_field_9_ = 0;
	range_field_b_ = 0;
	number_of_item_ = 0;
	}

Object_Header::~Object_Header()
	{
	switch ( range_field_case_index() )
		{
		case 0:
			// Clean up "range_field_0"
			{
			delete range_field_0_;
			range_field_0_ = 0;
			}
			break;
		case 1:
			// Clean up "range_field_1"
			{
			delete range_field_1_;
			range_field_1_ = 0;
			}
			break;
		case 2:
			// Clean up "range_field_2"
			{
			delete range_field_2_;
			range_field_2_ = 0;
			}
			break;
		case 3:
			// Clean up "range_field_3"
			{
			delete range_field_3_;
			range_field_3_ = 0;
			}
			break;
		case 4:
			// Clean up "range_field_4"
			{
			delete range_field_4_;
			range_field_4_ = 0;
			}
			break;
		case 5:
			// Clean up "range_field_5"
			{
			delete range_field_5_;
			range_field_5_ = 0;
			}
			break;
		case 6:
			// Clean up "range_field_6"
			{
			}
			break;
		case 7:
			// Clean up "range_field_7"
			{
			}
			break;
		case 8:
			// Clean up "range_field_8"
			{
			}
			break;
		case 9:
			// Clean up "range_field_9"
			{
			}
			break;
		case 11:
			// Clean up "range_field_b"
			{
			}
			break;
		default:
			// Clean up "unknown"
			{
			unknown_.free();
			}
			break;
		}
	}

int Object_Header::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, int t_byteorder)
	{
	// Checking out-of-bound for "Object_Header:qualifier_field"
	if ( (t_begin_of_data + 2) + (1) > t_end_of_data )
		{
		// Handle out-of-bound condition
		throw ExceptionOutOfBound("Object_Header:qualifier_field",
			(2) + (1), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "object_type_field"
	object_type_field_ = FixByteOrder(t_byteorder, *((uint16 const *) (t_begin_of_data)));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "qualifier_field"
	qualifier_field_ = *((uint8 const *) ((t_begin_of_data + 2)));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "range_field"
	int t_range_field__size;
	range_field_case_index_ =  ( qualifier_field() & 0x0f ) ;
	switch ( range_field_case_index() )
		{
		case 0:
			// Parse "range_field_0"
			{
			range_field_0_ = new Range_Field_0();
			range_field_0_->Parse((t_begin_of_data + 3), t_end_of_data);
			// Evaluate 'let' and 'withinput' fields
			t_range_field__size = 2;
			}
			break;
		case 1:
			// Parse "range_field_1"
			{
			range_field_1_ = new Range_Field_1();
			range_field_1_->Parse((t_begin_of_data + 3), t_end_of_data, t_byteorder);
			// Evaluate 'let' and 'withinput' fields
			t_range_field__size = 4;
			}
			break;
		case 2:
			// Parse "range_field_2"
			{
			range_field_2_ = new Range_Field_2();
			range_field_2_->Parse((t_begin_of_data + 3), t_end_of_data, t_byteorder);
			// Evaluate 'let' and 'withinput' fields
			t_range_field__size = 8;
			}
			break;
		case 3:
			// Parse "range_field_3"
			{
			range_field_3_ = new Range_Field_3();
			range_field_3_->Parse((t_begin_of_data + 3), t_end_of_data);
			// Evaluate 'let' and 'withinput' fields
			t_range_field__size = 2;
			}
			break;
		case 4:
			// Parse "range_field_4"
			{
			range_field_4_ = new Range_Field_4();
			range_field_4_->Parse((t_begin_of_data + 3), t_end_of_data, t_byteorder);
			// Evaluate 'let' and 'withinput' fields
			t_range_field__size = 4;
			}
			break;
		case 5:
			// Parse "range_field_5"
			{
			range_field_5_ = new Range_Field_5();
			range_field_5_->Parse((t_begin_of_data + 3), t_end_of_data, t_byteorder);
			// Evaluate 'let' and 'withinput' fields
			t_range_field__size = 8;
			}
			break;
		case 6:
			// Parse "range_field_6"
			{
			// Evaluate 'let' and 'withinput' fields
			t_range_field__size = 0;
			}
			break;
		case 7:
			// Parse "range_field_7"
			{
			// Checking out-of-bound for "Object_Header:range_field_7"
			if ( (t_begin_of_data + 3) + (1) > t_end_of_data )
				{
				// Handle out-of-bound condition
				throw ExceptionOutOfBound("Object_Header:range_field_7",
					(3) + (1), 
					(t_end_of_data) - (t_begin_of_data));
				}
			range_field_7_ = *((uint8 const *) ((t_begin_of_data + 3)));
			// Evaluate 'let' and 'withinput' fields
			t_range_field__size = 1;
			}
			break;
		case 8:
			// Parse "range_field_8"
			{
			// Checking out-of-bound for "Object_Header:range_field_8"
			if ( (t_begin_of_data + 3) + (2) > t_end_of_data )
				{
				// Handle out-of-bound condition
				throw ExceptionOutOfBound("Object_Header:range_field_8",
					(3) + (2), 
					(t_end_of_data) - (t_begin_of_data));
				}
			range_field_8_ = FixByteOrder(t_byteorder, *((uint16 const *) ((t_begin_of_data + 3))));
			// Evaluate 'let' and 'withinput' fields
			t_range_field__size = 2;
			}
			break;
		case 9:
			// Parse "range_field_9"
			{
			// Checking out-of-bound for "Object_Header:range_field_9"
			if ( (t_begin_of_data + 3) + (4) > t_end_of_data )
				{
				// Handle out-of-bound condition
				throw ExceptionOutOfBound("Object_Header:range_field_9",
					(3) + (4), 
					(t_end_of_data) - (t_begin_of_data));
				}
			range_field_9_ = FixByteOrder(t_byteorder, *((uint32 const *) ((t_begin_of_data + 3))));
			// Evaluate 'let' and 'withinput' fields
			t_range_field__size = 4;
			}
			break;
		case 11:
			// Parse "range_field_b"
			{
			// Checking out-of-bound for "Object_Header:range_field_b"
			if ( (t_begin_of_data + 3) + (1) > t_end_of_data )
				{
				// Handle out-of-bound condition
				throw ExceptionOutOfBound("Object_Header:range_field_b",
					(3) + (1), 
					(t_end_of_data) - (t_begin_of_data));
				}
			range_field_b_ = *((uint8 const *) ((t_begin_of_data + 3)));
			// Evaluate 'let' and 'withinput' fields
			t_range_field__size = 1;
			}
			break;
		default:
			// Parse "unknown"
			{
			int t_unknown_string_length;
			t_unknown_string_length = (t_end_of_data) - ((t_begin_of_data + 3));
			int t_unknown__size;
			t_unknown__size = t_unknown_string_length;
			// check for negative sizes
			if ( t_unknown_string_length < 0 )
			throw ExceptionInvalidStringLength("./dnp3-protocol.pac:97", t_unknown_string_length);
			unknown_.init((t_begin_of_data + 3), t_unknown_string_length);
			// Evaluate 'let' and 'withinput' fields
			t_range_field__size = t_unknown__size;
			}
			break;
		}
	// Evaluate 'let' and 'withinput' fields
	
	int t_Object_Header__size;
	const_byteptr const t_dataptr_after_range_field = (t_begin_of_data + 3) + (t_range_field__size);
	BINPAC_ASSERT(t_dataptr_after_range_field <= t_end_of_data);
	t_Object_Header__size = t_dataptr_after_range_field - t_begin_of_data;
	// Evaluate 'let' and 'withinput' fields
	uint8 t_t_var_001;
	switch (  ( qualifier_field() & 0x0f )  )
		{
		case 7:
			t_t_var_001 = range_field_7();
			break;
		case 8:
			t_t_var_001 = range_field_8();
			break;
		case 9:
			t_t_var_001 = range_field_9();
			break;
		default:
			t_t_var_001 = 0;
			break;
		}
	number_of_item_ = t_t_var_001;
	BINPAC_ASSERT(t_begin_of_data + (t_Object_Header__size) <= t_end_of_data);
	return t_Object_Header__size;
	}

Range_Field_0::Range_Field_0()
	{
	start_index_ = 0;
	stop_index_ = 0;
	}

Range_Field_0::~Range_Field_0()
	{
	}

int Range_Field_0::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data)
	{
	// Checking out-of-bound for "Range_Field_0"
	if ( t_begin_of_data + (2) > t_end_of_data )
		{
		// Handle out-of-bound condition
		throw ExceptionOutOfBound("Range_Field_0",
			(0) + (2), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "start_index"
	start_index_ = *((uint8 const *) (t_begin_of_data));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "stop_index"
	stop_index_ = *((uint8 const *) ((t_begin_of_data + 1)));
	// Evaluate 'let' and 'withinput' fields
	
	// Evaluate 'let' and 'withinput' fields
	BINPAC_ASSERT(t_begin_of_data + (2) <= t_end_of_data);
	return 2;
	}

Range_Field_1::Range_Field_1()
	{
	start_index_ = 0;
	stop_index_ = 0;
	}

Range_Field_1::~Range_Field_1()
	{
	}

int Range_Field_1::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, int t_byteorder)
	{
	// Checking out-of-bound for "Range_Field_1"
	if ( t_begin_of_data + (4) > t_end_of_data )
		{
		// Handle out-of-bound condition
		throw ExceptionOutOfBound("Range_Field_1",
			(0) + (4), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "start_index"
	start_index_ = FixByteOrder(t_byteorder, *((uint16 const *) (t_begin_of_data)));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "stop_index"
	stop_index_ = FixByteOrder(t_byteorder, *((uint16 const *) ((t_begin_of_data + 2))));
	// Evaluate 'let' and 'withinput' fields
	
	// Evaluate 'let' and 'withinput' fields
	BINPAC_ASSERT(t_begin_of_data + (4) <= t_end_of_data);
	return 4;
	}

Range_Field_2::Range_Field_2()
	{
	start_index_ = 0;
	stop_index_ = 0;
	}

Range_Field_2::~Range_Field_2()
	{
	}

int Range_Field_2::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, int t_byteorder)
	{
	// Checking out-of-bound for "Range_Field_2"
	if ( t_begin_of_data + (8) > t_end_of_data )
		{
		// Handle out-of-bound condition
		throw ExceptionOutOfBound("Range_Field_2",
			(0) + (8), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "start_index"
	start_index_ = FixByteOrder(t_byteorder, *((uint32 const *) (t_begin_of_data)));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "stop_index"
	stop_index_ = FixByteOrder(t_byteorder, *((uint32 const *) ((t_begin_of_data + 4))));
	// Evaluate 'let' and 'withinput' fields
	
	// Evaluate 'let' and 'withinput' fields
	BINPAC_ASSERT(t_begin_of_data + (8) <= t_end_of_data);
	return 8;
	}

Range_Field_3::Range_Field_3()
	{
	start_addr_ = 0;
	stop_addr_ = 0;
	}

Range_Field_3::~Range_Field_3()
	{
	}

int Range_Field_3::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data)
	{
	// Checking out-of-bound for "Range_Field_3"
	if ( t_begin_of_data + (2) > t_end_of_data )
		{
		// Handle out-of-bound condition
		throw ExceptionOutOfBound("Range_Field_3",
			(0) + (2), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "start_addr"
	start_addr_ = *((uint8 const *) (t_begin_of_data));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "stop_addr"
	stop_addr_ = *((uint8 const *) ((t_begin_of_data + 1)));
	// Evaluate 'let' and 'withinput' fields
	
	// Evaluate 'let' and 'withinput' fields
	BINPAC_ASSERT(t_begin_of_data + (2) <= t_end_of_data);
	return 2;
	}

Range_Field_4::Range_Field_4()
	{
	start_addr_ = 0;
	stop_addr_ = 0;
	}

Range_Field_4::~Range_Field_4()
	{
	}

int Range_Field_4::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, int t_byteorder)
	{
	// Checking out-of-bound for "Range_Field_4"
	if ( t_begin_of_data + (4) > t_end_of_data )
		{
		// Handle out-of-bound condition
		throw ExceptionOutOfBound("Range_Field_4",
			(0) + (4), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "start_addr"
	start_addr_ = FixByteOrder(t_byteorder, *((uint16 const *) (t_begin_of_data)));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "stop_addr"
	stop_addr_ = FixByteOrder(t_byteorder, *((uint16 const *) ((t_begin_of_data + 2))));
	// Evaluate 'let' and 'withinput' fields
	
	// Evaluate 'let' and 'withinput' fields
	BINPAC_ASSERT(t_begin_of_data + (4) <= t_end_of_data);
	return 4;
	}

Range_Field_5::Range_Field_5()
	{
	start_addr_ = 0;
	stop_addr_ = 0;
	}

Range_Field_5::~Range_Field_5()
	{
	}

int Range_Field_5::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, int t_byteorder)
	{
	// Checking out-of-bound for "Range_Field_5"
	if ( t_begin_of_data + (8) > t_end_of_data )
		{
		// Handle out-of-bound condition
		throw ExceptionOutOfBound("Range_Field_5",
			(0) + (8), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "start_addr"
	start_addr_ = FixByteOrder(t_byteorder, *((uint32 const *) (t_begin_of_data)));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "stop_addr"
	stop_addr_ = FixByteOrder(t_byteorder, *((uint32 const *) ((t_begin_of_data + 4))));
	// Evaluate 'let' and 'withinput' fields
	
	// Evaluate 'let' and 'withinput' fields
	BINPAC_ASSERT(t_begin_of_data + (8) <= t_end_of_data);
	return 8;
	}

Object_With_Header::Object_With_Header()
	{
	object_header_ = 0;
	}

Object_With_Header::~Object_With_Header()
	{
	delete object_header_;
	object_header_ = 0;
	}

int Object_With_Header::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, int t_byteorder)
	{
	// Parse "object_header"
	object_header_ = new Object_Header();
	int t_object_header__size;
	t_object_header__size = object_header_->Parse(t_begin_of_data, t_end_of_data, t_byteorder);
	// Evaluate 'let' and 'withinput' fields
	
	int t_Object_With_Header__size;
	const_byteptr const t_dataptr_after_object_header = t_begin_of_data + (t_object_header__size);
	BINPAC_ASSERT(t_dataptr_after_object_header <= t_end_of_data);
	t_Object_With_Header__size = t_dataptr_after_object_header - t_begin_of_data;
	// Evaluate 'let' and 'withinput' fields
	BINPAC_ASSERT(t_begin_of_data + (t_Object_With_Header__size) <= t_end_of_data);
	return t_Object_With_Header__size;
	}

AnalogInput32woTime::AnalogInput32woTime()
	{
	flag_ = 0;
	value_ = 0;
	}

AnalogInput32woTime::~AnalogInput32woTime()
	{
	}

int AnalogInput32woTime::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, int t_byteorder)
	{
	// Checking out-of-bound for "AnalogInput32woTime"
	if ( t_begin_of_data + (5) > t_end_of_data )
		{
		// Handle out-of-bound condition
		throw ExceptionOutOfBound("AnalogInput32woTime",
			(0) + (5), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "flag"
	flag_ = *((uint8 const *) (t_begin_of_data));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "value"
	value_ = FixByteOrder(t_byteorder, *((uint32 const *) ((t_begin_of_data + 1))));
	// Evaluate 'let' and 'withinput' fields
	
	// Evaluate 'let' and 'withinput' fields
	BINPAC_ASSERT(t_begin_of_data + (5) <= t_end_of_data);
	return 5;
	}

AnalogInput16woTime::AnalogInput16woTime()
	{
	flag_ = 0;
	value_ = 0;
	}

AnalogInput16woTime::~AnalogInput16woTime()
	{
	}

int AnalogInput16woTime::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, int t_byteorder)
	{
	// Checking out-of-bound for "AnalogInput16woTime"
	if ( t_begin_of_data + (3) > t_end_of_data )
		{
		// Handle out-of-bound condition
		throw ExceptionOutOfBound("AnalogInput16woTime",
			(0) + (3), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "flag"
	flag_ = *((uint8 const *) (t_begin_of_data));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "value"
	value_ = FixByteOrder(t_byteorder, *((uint16 const *) ((t_begin_of_data + 1))));
	// Evaluate 'let' and 'withinput' fields
	
	// Evaluate 'let' and 'withinput' fields
	BINPAC_ASSERT(t_begin_of_data + (3) <= t_end_of_data);
	return 3;
	}

AnalogInput32wTime::AnalogInput32wTime()
	{
	flag_ = 0;
	value_ = 0;
	time_ = 0;
	time__elem_ = 0;
	}

AnalogInput32wTime::~AnalogInput32wTime()
	{
	delete time_;
	}

int AnalogInput32wTime::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, int t_byteorder)
	{
	// Checking out-of-bound for "AnalogInput32wTime"
	if ( t_begin_of_data + (11) > t_end_of_data )
		{
		// Handle out-of-bound condition
		throw ExceptionOutOfBound("AnalogInput32wTime",
			(0) + (11), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "flag"
	flag_ = *((uint8 const *) (t_begin_of_data));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "value"
	value_ = FixByteOrder(t_byteorder, *((uint32 const *) ((t_begin_of_data + 1))));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "time"
	int t_time__arraylength;
	t_time__arraylength = 6;
	if ( t_begin_of_data + t_time__arraylength > t_end_of_data + 1 )
		{
		t_time__arraylength = t_end_of_data - t_begin_of_data + 1;
		}
	if ( t_time__arraylength < 0 )
		{
		t_time__arraylength = 0;
		}
	time__elem_ = 0;
	int t_time__elem__it;
	t_time__elem__it = 0;
	time_ = new vector<uint8>;
	time_->reserve(t_time__arraylength);
	const_byteptr t_time__elem__dataptr = (t_begin_of_data + 5);
	for (; t_time__elem__it < t_time__arraylength; ++t_time__elem__it)
		{
		// Check &until(time__elem__dataptr >= end_of_data)
		if ( t_time__elem__dataptr >= t_end_of_data )
			{
			goto end_of_time;
			}
		time__elem_ = *((uint8 const *) (t_time__elem__dataptr));
		// Evaluate 'let' and 'withinput' fields
		time_->push_back(time__elem_);
		t_time__elem__dataptr += 1;
		BINPAC_ASSERT(t_time__elem__dataptr <= t_end_of_data);
		}
end_of_time: ;
	// Evaluate 'let' and 'withinput' fields
	
	// Evaluate 'let' and 'withinput' fields
	BINPAC_ASSERT(t_begin_of_data + (11) <= t_end_of_data);
	return 11;
	}

AnalogInput16wTime::AnalogInput16wTime()
	{
	flag_ = 0;
	value_ = 0;
	time_ = 0;
	time__elem_ = 0;
	}

AnalogInput16wTime::~AnalogInput16wTime()
	{
	delete time_;
	}

int AnalogInput16wTime::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, int t_byteorder)
	{
	// Checking out-of-bound for "AnalogInput16wTime"
	if ( t_begin_of_data + (9) > t_end_of_data )
		{
		// Handle out-of-bound condition
		throw ExceptionOutOfBound("AnalogInput16wTime",
			(0) + (9), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "flag"
	flag_ = *((uint8 const *) (t_begin_of_data));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "value"
	value_ = FixByteOrder(t_byteorder, *((uint16 const *) ((t_begin_of_data + 1))));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "time"
	int t_time__arraylength;
	t_time__arraylength = 6;
	if ( t_begin_of_data + t_time__arraylength > t_end_of_data + 1 )
		{
		t_time__arraylength = t_end_of_data - t_begin_of_data + 1;
		}
	if ( t_time__arraylength < 0 )
		{
		t_time__arraylength = 0;
		}
	time__elem_ = 0;
	int t_time__elem__it;
	t_time__elem__it = 0;
	time_ = new vector<uint8>;
	time_->reserve(t_time__arraylength);
	const_byteptr t_time__elem__dataptr = (t_begin_of_data + 3);
	for (; t_time__elem__it < t_time__arraylength; ++t_time__elem__it)
		{
		// Check &until(time__elem__dataptr >= end_of_data)
		if ( t_time__elem__dataptr >= t_end_of_data )
			{
			goto end_of_time;
			}
		time__elem_ = *((uint8 const *) (t_time__elem__dataptr));
		// Evaluate 'let' and 'withinput' fields
		time_->push_back(time__elem_);
		t_time__elem__dataptr += 1;
		BINPAC_ASSERT(t_time__elem__dataptr <= t_end_of_data);
		}
end_of_time: ;
	// Evaluate 'let' and 'withinput' fields
	
	// Evaluate 'let' and 'withinput' fields
	BINPAC_ASSERT(t_begin_of_data + (9) <= t_end_of_data);
	return 9;
	}

AnalogInputSPwoTime::AnalogInputSPwoTime()
	{
	flag_ = 0;
	value_ = 0;
	}

AnalogInputSPwoTime::~AnalogInputSPwoTime()
	{
	}

int AnalogInputSPwoTime::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, int t_byteorder)
	{
	// Checking out-of-bound for "AnalogInputSPwoTime"
	if ( t_begin_of_data + (5) > t_end_of_data )
		{
		// Handle out-of-bound condition
		throw ExceptionOutOfBound("AnalogInputSPwoTime",
			(0) + (5), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "flag"
	flag_ = *((uint8 const *) (t_begin_of_data));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "value"
	value_ = FixByteOrder(t_byteorder, *((uint32 const *) ((t_begin_of_data + 1))));
	// Evaluate 'let' and 'withinput' fields
	
	// Evaluate 'let' and 'withinput' fields
	BINPAC_ASSERT(t_begin_of_data + (5) <= t_end_of_data);
	return 5;
	}

AnalogInputDPwoTime::AnalogInputDPwoTime()
	{
	flag_ = 0;
	value_ = 0;
	value__elem_ = 0;
	}

AnalogInputDPwoTime::~AnalogInputDPwoTime()
	{
	delete value_;
	}

int AnalogInputDPwoTime::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, int t_byteorder)
	{
	// Checking out-of-bound for "AnalogInputDPwoTime"
	if ( t_begin_of_data + (9) > t_end_of_data )
		{
		// Handle out-of-bound condition
		throw ExceptionOutOfBound("AnalogInputDPwoTime",
			(0) + (9), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "flag"
	flag_ = *((uint8 const *) (t_begin_of_data));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "value"
	int t_value__arraylength;
	t_value__arraylength = 2;
	if ( t_begin_of_data + t_value__arraylength > t_end_of_data + 1 )
		{
		t_value__arraylength = t_end_of_data - t_begin_of_data + 1;
		}
	if ( t_value__arraylength < 0 )
		{
		t_value__arraylength = 0;
		}
	value__elem_ = 0;
	int t_value__elem__it;
	t_value__elem__it = 0;
	value_ = new vector<uint32>;
	value_->reserve(t_value__arraylength);
	const_byteptr t_value__elem__dataptr = (t_begin_of_data + 1);
	for (; t_value__elem__it < t_value__arraylength; ++t_value__elem__it)
		{
		// Check &until(value__elem__dataptr >= end_of_data)
		if ( t_value__elem__dataptr >= t_end_of_data )
			{
			goto end_of_value;
			}
		value__elem_ = FixByteOrder(t_byteorder, *((uint32 const *) (t_value__elem__dataptr)));
		// Evaluate 'let' and 'withinput' fields
		value_->push_back(value__elem_);
		t_value__elem__dataptr += 4;
		BINPAC_ASSERT(t_value__elem__dataptr <= t_end_of_data);
		}
end_of_value: ;
	// Evaluate 'let' and 'withinput' fields
	
	// Evaluate 'let' and 'withinput' fields
	BINPAC_ASSERT(t_begin_of_data + (9) <= t_end_of_data);
	return 9;
	}

AnalogInputSPwTime::AnalogInputSPwTime()
	{
	flag_ = 0;
	value_ = 0;
	time_ = 0;
	time__elem_ = 0;
	}

AnalogInputSPwTime::~AnalogInputSPwTime()
	{
	delete time_;
	}

int AnalogInputSPwTime::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, int t_byteorder)
	{
	// Checking out-of-bound for "AnalogInputSPwTime"
	if ( t_begin_of_data + (11) > t_end_of_data )
		{
		// Handle out-of-bound condition
		throw ExceptionOutOfBound("AnalogInputSPwTime",
			(0) + (11), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "flag"
	flag_ = *((uint8 const *) (t_begin_of_data));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "value"
	value_ = FixByteOrder(t_byteorder, *((uint32 const *) ((t_begin_of_data + 1))));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "time"
	int t_time__arraylength;
	t_time__arraylength = 6;
	if ( t_begin_of_data + t_time__arraylength > t_end_of_data + 1 )
		{
		t_time__arraylength = t_end_of_data - t_begin_of_data + 1;
		}
	if ( t_time__arraylength < 0 )
		{
		t_time__arraylength = 0;
		}
	time__elem_ = 0;
	int t_time__elem__it;
	t_time__elem__it = 0;
	time_ = new vector<uint8>;
	time_->reserve(t_time__arraylength);
	const_byteptr t_time__elem__dataptr = (t_begin_of_data + 5);
	for (; t_time__elem__it < t_time__arraylength; ++t_time__elem__it)
		{
		// Check &until(time__elem__dataptr >= end_of_data)
		if ( t_time__elem__dataptr >= t_end_of_data )
			{
			goto end_of_time;
			}
		time__elem_ = *((uint8 const *) (t_time__elem__dataptr));
		// Evaluate 'let' and 'withinput' fields
		time_->push_back(time__elem_);
		t_time__elem__dataptr += 1;
		BINPAC_ASSERT(t_time__elem__dataptr <= t_end_of_data);
		}
end_of_time: ;
	// Evaluate 'let' and 'withinput' fields
	
	// Evaluate 'let' and 'withinput' fields
	BINPAC_ASSERT(t_begin_of_data + (11) <= t_end_of_data);
	return 11;
	}

AnalogInputDPwTime::AnalogInputDPwTime()
	{
	flag_ = 0;
	value_ = 0;
	value__elem_ = 0;
	time_ = 0;
	time__elem_ = 0;
	}

AnalogInputDPwTime::~AnalogInputDPwTime()
	{
	delete value_;
	delete time_;
	}

int AnalogInputDPwTime::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, int t_byteorder)
	{
	// Checking out-of-bound for "AnalogInputDPwTime"
	if ( t_begin_of_data + (15) > t_end_of_data )
		{
		// Handle out-of-bound condition
		throw ExceptionOutOfBound("AnalogInputDPwTime",
			(0) + (15), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "flag"
	flag_ = *((uint8 const *) (t_begin_of_data));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "value"
	int t_value__arraylength;
	t_value__arraylength = 2;
	if ( t_begin_of_data + t_value__arraylength > t_end_of_data + 1 )
		{
		t_value__arraylength = t_end_of_data - t_begin_of_data + 1;
		}
	if ( t_value__arraylength < 0 )
		{
		t_value__arraylength = 0;
		}
	value__elem_ = 0;
	int t_value__elem__it;
	t_value__elem__it = 0;
	value_ = new vector<uint32>;
	value_->reserve(t_value__arraylength);
	const_byteptr t_value__elem__dataptr = (t_begin_of_data + 1);
	for (; t_value__elem__it < t_value__arraylength; ++t_value__elem__it)
		{
		// Check &until(value__elem__dataptr >= end_of_data)
		if ( t_value__elem__dataptr >= t_end_of_data )
			{
			goto end_of_value;
			}
		value__elem_ = FixByteOrder(t_byteorder, *((uint32 const *) (t_value__elem__dataptr)));
		// Evaluate 'let' and 'withinput' fields
		value_->push_back(value__elem_);
		t_value__elem__dataptr += 4;
		BINPAC_ASSERT(t_value__elem__dataptr <= t_end_of_data);
		}
end_of_value: ;
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "time"
	int t_time__arraylength;
	t_time__arraylength = 6;
	if ( t_begin_of_data + t_time__arraylength > t_end_of_data + 1 )
		{
		t_time__arraylength = t_end_of_data - t_begin_of_data + 1;
		}
	if ( t_time__arraylength < 0 )
		{
		t_time__arraylength = 0;
		}
	time__elem_ = 0;
	int t_time__elem__it;
	t_time__elem__it = 0;
	time_ = new vector<uint8>;
	time_->reserve(t_time__arraylength);
	const_byteptr t_time__elem__dataptr = (t_begin_of_data + 9);
	for (; t_time__elem__it < t_time__arraylength; ++t_time__elem__it)
		{
		// Check &until(time__elem__dataptr >= end_of_data)
		if ( t_time__elem__dataptr >= t_end_of_data )
			{
			goto end_of_time;
			}
		time__elem_ = *((uint8 const *) (t_time__elem__dataptr));
		// Evaluate 'let' and 'withinput' fields
		time_->push_back(time__elem_);
		t_time__elem__dataptr += 1;
		BINPAC_ASSERT(t_time__elem__dataptr <= t_end_of_data);
		}
end_of_time: ;
	// Evaluate 'let' and 'withinput' fields
	
	// Evaluate 'let' and 'withinput' fields
	BINPAC_ASSERT(t_begin_of_data + (15) <= t_end_of_data);
	return 15;
	}

Dnp3_Conn::Dnp3_Conn(BroAnalyzer const & bro_analyzer)
	{
	upflow_ = new Dnp3_Flow(this, true);
	downflow_ = new Dnp3_Flow(this, false);
	bro_analyzer_ = bro_analyzer;
	}

Dnp3_Conn::~Dnp3_Conn()
	{
	delete upflow_;
	upflow_ = 0;
	delete downflow_;
	downflow_ = 0;
	}

void Dnp3_Conn::NewData(bool is_orig, const_byteptr begin, const_byteptr end)
	{
	if ( is_orig )
		upflow_->NewData(begin, end);
	else
		downflow_->NewData(begin, end);
	}

void Dnp3_Conn::NewGap(bool is_orig, int gap_length)
	{
	if ( is_orig )
		upflow_->NewGap(gap_length);
	else
		downflow_->NewGap(gap_length);
	}

void Dnp3_Conn::FlowEOF(bool is_orig)
	{
	if ( is_orig )
		upflow_->FlowEOF();
	else
		downflow_->FlowEOF();
	}

Dnp3_Flow::Dnp3_Flow(Dnp3_Conn * connection, bool is_orig)
	{
	connection_ = connection;
	is_orig_ = is_orig;
	dataunit_ = 0;
	context_ = 0;
	}

Dnp3_Flow::~Dnp3_Flow()
	{
	delete dataunit_;
	dataunit_ = 0;
	delete context_;
	context_ = 0;
	}

void Dnp3_Flow::NewData(const_byteptr t_begin_of_data, const_byteptr t_end_of_data)
	{
	try
		{
		dataunit_ = new Dnp3_PDU(is_orig());
		context_ = new ContextDnp3(connection(), this);
		int t_dataunit__size;
		t_dataunit__size = dataunit_->Parse(t_begin_of_data, t_end_of_data);
		// Evaluate 'let' and 'withinput' fields
		delete dataunit_;
		dataunit_ = 0;
		delete context_;
		context_ = 0;
		}
	catch ( Exception const &e )
		{
		delete dataunit_;
		dataunit_ = 0;
		delete context_;
		context_ = 0;
		throw e;
		}
	}

void Dnp3_Flow::NewGap(int gap_length)
	{
	}
void Dnp3_Flow::FlowEOF()
	{
	}
bool Dnp3_Flow::deliver_message(uint16 length)
	{

		if ( ::sample_message )
			{
			BifEvent::generate_sample_message(
				connection()->bro_analyzer(),
				connection()->bro_analyzer()->Conn(),
				is_orig(), length);
			}

		return true;
		
	}

} // namespace Dnp3
}  // namespace binpac
