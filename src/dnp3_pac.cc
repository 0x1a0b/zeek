// This file is automatically generated from dnp3.pac.

#include "dnp3_pac.h"

namespace binpac {






namespace Dnp3 {
ContextDnp3::ContextDnp3(Dnp3_Conn * connection, Dnp3_Flow * flow)
	{
	connection_ = connection;
	flow_ = flow;
	}

ContextDnp3::~ContextDnp3()
	{
	}

Dnp3_PDU::Dnp3_PDU(bool is_orig)
	{
	val_case_index_ = -1;
	request_ = 0;
	response_ = 0;
	is_orig_ = is_orig;
	byteorder_ = bigendian;
	}

Dnp3_PDU::~Dnp3_PDU()
	{
	switch ( val_case_index() )
		{
		case 1:
			// Clean up "request"
			{
			delete request_;
			request_ = 0;
			}
			break;
		case 0:
			// Clean up "response"
			{
			delete response_;
			response_ = 0;
			}
			break;
		}
	}

int Dnp3_PDU::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data)
	{
	int t_val__size;
	val_case_index_ = is_orig();
	switch ( val_case_index() )
		{
		case 1:
			// Parse "request"
			{
			request_ = new Dnp3_Request();
			int t_request__size;
			t_request__size = request_->Parse(t_begin_of_data, t_end_of_data, byteorder());
			// Evaluate 'let' and 'withinput' fields
			t_val__size = t_request__size;
			}
			break;
		case 0:
			// Parse "response"
			{
			response_ = new Dnp3_Response();
			int t_response__size;
			t_response__size = response_->Parse(t_begin_of_data, t_end_of_data);
			// Evaluate 'let' and 'withinput' fields
			t_val__size = t_response__size;
			}
			break;
		default:
			throw ExceptionInvalidCaseIndex("Dnp3_PDU", val_case_index());
			break;
		}
	// Evaluate 'let' and 'withinput' fields
	BINPAC_ASSERT(t_begin_of_data + (t_val__size) <= t_end_of_data);
	return t_val__size;
	}

Dnp3_Request::Dnp3_Request()
	{
	app_header_ = 0;
	data_case_index_ = -1;
	objects_ = 0;
	}

Dnp3_Request::~Dnp3_Request()
	{
	delete app_header_;
	app_header_ = 0;
	switch ( data_case_index() )
		{
		case 0:
			// Clean up "none_coonfirm"
			{
			}
			break;
		case 1:
			// Clean up "objects"
			{
			delete objects_;
			objects_ = 0;
			}
			break;
		default:
			// Clean up "unknown"
			{
			unknown_.free();
			}
			break;
		}
	}

int Dnp3_Request::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, int t_byteorder)
	{
	// Checking out-of-bound for "Dnp3_Request:app_header"
	if ( t_begin_of_data + (2) > t_end_of_data )
		{
		// Handle out-of-bound condition
		throw ExceptionOutOfBound("Dnp3_Request:app_header",
			(0) + (2), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "app_header"
	app_header_ = new Dnp3_Application_Request_Header();
	app_header_->Parse(t_begin_of_data, t_end_of_data);
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "data"
	int t_data__size;
	data_case_index_ = app_header()->function_code();
	switch ( data_case_index() )
		{
		case 0:
			// Parse "none_coonfirm"
			{
			// Evaluate 'let' and 'withinput' fields
			t_data__size = 0;
			}
			break;
		case 1:
			// Parse "objects"
			{
			objects_ = new Request_Objects();
			int t_objects__size;
			t_objects__size = objects_->Parse((t_begin_of_data + 2), t_end_of_data, t_byteorder);
			// Evaluate 'let' and 'withinput' fields
			t_data__size = t_objects__size;
			}
			break;
		default:
			// Parse "unknown"
			{
			int t_unknown_string_length;
			t_unknown_string_length = (t_end_of_data) - ((t_begin_of_data + 2));
			int t_unknown__size;
			t_unknown__size = t_unknown_string_length;
			// check for negative sizes
			if ( t_unknown_string_length < 0 )
			throw ExceptionInvalidStringLength("./dnp3-protocol.pac:15", t_unknown_string_length);
			unknown_.init((t_begin_of_data + 2), t_unknown_string_length);
			// Evaluate 'let' and 'withinput' fields
			t_data__size = t_unknown__size;
			}
			break;
		}
	// Evaluate 'let' and 'withinput' fields
	
	int t_Dnp3_Request__size;
	const_byteptr const t_dataptr_after_data = (t_begin_of_data + 2) + (t_data__size);
	BINPAC_ASSERT(t_dataptr_after_data <= t_end_of_data);
	t_Dnp3_Request__size = t_dataptr_after_data - t_begin_of_data;
	// Evaluate 'let' and 'withinput' fields
	BINPAC_ASSERT(t_begin_of_data + (t_Dnp3_Request__size) <= t_end_of_data);
	return t_Dnp3_Request__size;
	}

Dnp3_Response::Dnp3_Response()
	{
	app_header_ = 0;
	data_case_index_ = -1;
	}

Dnp3_Response::~Dnp3_Response()
	{
	delete app_header_;
	app_header_ = 0;
	switch ( data_case_index() )
		{
		default:
			// Clean up "unknown"
			{
			unknown_.free();
			}
			break;
		}
	}

int Dnp3_Response::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data)
	{
	// Checking out-of-bound for "Dnp3_Response:app_header"
	if ( t_begin_of_data + (4) > t_end_of_data )
		{
		// Handle out-of-bound condition
		throw ExceptionOutOfBound("Dnp3_Response:app_header",
			(0) + (4), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "app_header"
	app_header_ = new Dnp3_Application_Response_Header();
	app_header_->Parse(t_begin_of_data, t_end_of_data);
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "data"
	int t_data__size;
	data_case_index_ = app_header()->function_code();
	switch ( data_case_index() )
		{
		default:
			// Parse "unknown"
			{
			int t_unknown_string_length;
			t_unknown_string_length = (t_end_of_data) - ((t_begin_of_data + 4));
			int t_unknown__size;
			t_unknown__size = t_unknown_string_length;
			// check for negative sizes
			if ( t_unknown_string_length < 0 )
			throw ExceptionInvalidStringLength("./dnp3-protocol.pac:23", t_unknown_string_length);
			unknown_.init((t_begin_of_data + 4), t_unknown_string_length);
			// Evaluate 'let' and 'withinput' fields
			t_data__size = t_unknown__size;
			}
			break;
		}
	// Evaluate 'let' and 'withinput' fields
	
	int t_Dnp3_Response__size;
	const_byteptr const t_dataptr_after_data = (t_begin_of_data + 4) + (t_data__size);
	BINPAC_ASSERT(t_dataptr_after_data <= t_end_of_data);
	t_Dnp3_Response__size = t_dataptr_after_data - t_begin_of_data;
	// Evaluate 'let' and 'withinput' fields
	BINPAC_ASSERT(t_begin_of_data + (t_Dnp3_Response__size) <= t_end_of_data);
	return t_Dnp3_Response__size;
	}

TypeOne::TypeOne()
	{
	mm1_ = 0;
	mm2_ = 0;
	len_ = 9;
	}

TypeOne::~TypeOne()
	{
	}

int TypeOne::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data)
	{
	// Checking out-of-bound for "TypeOne"
	if ( t_begin_of_data + (2) > t_end_of_data )
		{
		// Handle out-of-bound condition
		throw ExceptionOutOfBound("TypeOne",
			(0) + (2), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "mm1"
	mm1_ = *((uint8 const *) (t_begin_of_data));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "mm2"
	mm2_ = *((uint8 const *) ((t_begin_of_data + 1)));
	// Evaluate 'let' and 'withinput' fields
	
	// Evaluate 'let' and 'withinput' fields
	BINPAC_ASSERT(t_begin_of_data + (2) <= t_end_of_data);
	return 2;
	}

Dnp3_Application_Request_Header::Dnp3_Application_Request_Header()
	{
	application_control_ = 0;
	function_code_ = 0;
	}

Dnp3_Application_Request_Header::~Dnp3_Application_Request_Header()
	{
	}

int Dnp3_Application_Request_Header::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data)
	{
	// Checking out-of-bound for "Dnp3_Application_Request_Header"
	if ( t_begin_of_data + (2) > t_end_of_data )
		{
		// Handle out-of-bound condition
		throw ExceptionOutOfBound("Dnp3_Application_Request_Header",
			(0) + (2), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "application_control"
	application_control_ = *((uint8 const *) (t_begin_of_data));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "function_code"
	function_code_ = *((uint8 const *) ((t_begin_of_data + 1)));
	// Evaluate 'let' and 'withinput' fields
	
	// Evaluate 'let' and 'withinput' fields
	BINPAC_ASSERT(t_begin_of_data + (2) <= t_end_of_data);
	return 2;
	}

Dnp3_Application_Response_Header::Dnp3_Application_Response_Header()
	{
	application_control_ = 0;
	function_code_ = 0;
	internal_indications_ = 0;
	}

Dnp3_Application_Response_Header::~Dnp3_Application_Response_Header()
	{
	delete internal_indications_;
	internal_indications_ = 0;
	}

int Dnp3_Application_Response_Header::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data)
	{
	// Checking out-of-bound for "Dnp3_Application_Response_Header"
	if ( t_begin_of_data + (4) > t_end_of_data )
		{
		// Handle out-of-bound condition
		throw ExceptionOutOfBound("Dnp3_Application_Response_Header",
			(0) + (4), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "application_control"
	application_control_ = *((uint8 const *) (t_begin_of_data));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "function_code"
	function_code_ = *((uint8 const *) ((t_begin_of_data + 1)));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "internal_indications"
	internal_indications_ = new Response_Internal_Indication();
	internal_indications_->Parse((t_begin_of_data + 2), t_end_of_data);
	// Evaluate 'let' and 'withinput' fields
	
	// Evaluate 'let' and 'withinput' fields
	BINPAC_ASSERT(t_begin_of_data + (4) <= t_end_of_data);
	return 4;
	}

Response_Internal_Indication::Response_Internal_Indication()
	{
	first_octet_ = 0;
	second_octet_ = 0;
	}

Response_Internal_Indication::~Response_Internal_Indication()
	{
	}

int Response_Internal_Indication::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data)
	{
	// Checking out-of-bound for "Response_Internal_Indication"
	if ( t_begin_of_data + (2) > t_end_of_data )
		{
		// Handle out-of-bound condition
		throw ExceptionOutOfBound("Response_Internal_Indication",
			(0) + (2), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "first_octet"
	first_octet_ = *((uint8 const *) (t_begin_of_data));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "second_octet"
	second_octet_ = *((uint8 const *) ((t_begin_of_data + 1)));
	// Evaluate 'let' and 'withinput' fields
	
	// Evaluate 'let' and 'withinput' fields
	BINPAC_ASSERT(t_begin_of_data + (2) <= t_end_of_data);
	return 2;
	}

Request_Objects::Request_Objects()
	{
	object_header_ = 0;
	data_case_index_ = -1;
	}

Request_Objects::~Request_Objects()
	{
	delete object_header_;
	object_header_ = 0;
	switch ( data_case_index() )
		{
		case 15361:
			// Clean up "class0data"
			{
			}
			break;
		default:
			// Clean up "unknown"
			{
			unknown_.free();
			}
			break;
		}
	}

int Request_Objects::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, int t_byteorder)
	{
	// Parse "object_header"
	object_header_ = new Object_Header();
	int t_object_header__size;
	t_object_header__size = object_header_->Parse(t_begin_of_data, t_end_of_data, t_byteorder);
	// Evaluate 'let' and 'withinput' fields
	
	const_byteptr const t_dataptr_after_object_header = t_begin_of_data + (t_object_header__size);
	BINPAC_ASSERT(t_dataptr_after_object_header <= t_end_of_data);
	// Parse "data"
	int t_data__size;
	data_case_index_ =  ( object_header()->object_type_field() ) ;
	switch ( data_case_index() )
		{
		case 15361:
			// Parse "class0data"
			{
			// Evaluate 'let' and 'withinput' fields
			t_data__size = 0;
			}
			break;
		default:
			// Parse "unknown"
			{
			int t_unknown_string_length;
			t_unknown_string_length = (t_end_of_data) - (t_dataptr_after_object_header);
			int t_unknown__size;
			t_unknown__size = t_unknown_string_length;
			// check for negative sizes
			if ( t_unknown_string_length < 0 )
			throw ExceptionInvalidStringLength("./dnp3-protocol.pac:55", t_unknown_string_length);
			unknown_.init(t_dataptr_after_object_header, t_unknown_string_length);
			// Evaluate 'let' and 'withinput' fields
			t_data__size = t_unknown__size;
			}
			break;
		}
	// Evaluate 'let' and 'withinput' fields
	
	int t_Request_Objects__size;
	const_byteptr const t_dataptr_after_data = t_dataptr_after_object_header + (t_data__size);
	BINPAC_ASSERT(t_dataptr_after_data <= t_end_of_data);
	t_Request_Objects__size = t_dataptr_after_data - t_begin_of_data;
	// Evaluate 'let' and 'withinput' fields
	BINPAC_ASSERT(t_begin_of_data + (t_Request_Objects__size) <= t_end_of_data);
	return t_Request_Objects__size;
	}

Object_Header::Object_Header()
	{
	object_type_field_ = 0;
	qualifier_field_ = 0;
	range_field_case_index_ = -1;
	range_field_0_ = 0;
	range_field_1_ = 0;
	range_field_2_ = 0;
	range_field_3_ = 0;
	range_field_4_ = 0;
	range_field_5_ = 0;
	range_field_7_ = 0;
	range_field_8_ = 0;
	range_field_9_ = 0;
	range_field_b_ = 0;
	}

Object_Header::~Object_Header()
	{
	switch ( range_field_case_index() )
		{
		case 0:
			// Clean up "range_field_0"
			{
			delete range_field_0_;
			range_field_0_ = 0;
			}
			break;
		case 1:
			// Clean up "range_field_1"
			{
			delete range_field_1_;
			range_field_1_ = 0;
			}
			break;
		case 2:
			// Clean up "range_field_2"
			{
			delete range_field_2_;
			range_field_2_ = 0;
			}
			break;
		case 3:
			// Clean up "range_field_3"
			{
			delete range_field_3_;
			range_field_3_ = 0;
			}
			break;
		case 4:
			// Clean up "range_field_4"
			{
			delete range_field_4_;
			range_field_4_ = 0;
			}
			break;
		case 5:
			// Clean up "range_field_5"
			{
			delete range_field_5_;
			range_field_5_ = 0;
			}
			break;
		case 6:
			// Clean up "range_field_6"
			{
			}
			break;
		case 7:
			// Clean up "range_field_7"
			{
			delete range_field_7_;
			range_field_7_ = 0;
			}
			break;
		case 8:
			// Clean up "range_field_8"
			{
			delete range_field_8_;
			range_field_8_ = 0;
			}
			break;
		case 9:
			// Clean up "range_field_9"
			{
			delete range_field_9_;
			range_field_9_ = 0;
			}
			break;
		case 11:
			// Clean up "range_field_b"
			{
			delete range_field_b_;
			range_field_b_ = 0;
			}
			break;
		default:
			// Clean up "unknown"
			{
			unknown_.free();
			}
			break;
		}
	}

int Object_Header::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, int t_byteorder)
	{
	// Checking out-of-bound for "Object_Header:qualifier_field"
	if ( (t_begin_of_data + 2) + (1) > t_end_of_data )
		{
		// Handle out-of-bound condition
		throw ExceptionOutOfBound("Object_Header:qualifier_field",
			(2) + (1), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "object_type_field"
	object_type_field_ = FixByteOrder(t_byteorder, *((uint16 const *) (t_begin_of_data)));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "qualifier_field"
	qualifier_field_ = *((uint8 const *) ((t_begin_of_data + 2)));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "range_field"
	int t_range_field__size;
	range_field_case_index_ =  ( qualifier_field() & 0x0f ) ;
	switch ( range_field_case_index() )
		{
		case 0:
			// Parse "range_field_0"
			{
			range_field_0_ = new Range_Field_0();
			range_field_0_->Parse((t_begin_of_data + 3), t_end_of_data);
			// Evaluate 'let' and 'withinput' fields
			t_range_field__size = 2;
			}
			break;
		case 1:
			// Parse "range_field_1"
			{
			range_field_1_ = new Range_Field_1();
			range_field_1_->Parse((t_begin_of_data + 3), t_end_of_data, t_byteorder);
			// Evaluate 'let' and 'withinput' fields
			t_range_field__size = 4;
			}
			break;
		case 2:
			// Parse "range_field_2"
			{
			range_field_2_ = new Range_Field_2();
			range_field_2_->Parse((t_begin_of_data + 3), t_end_of_data, t_byteorder);
			// Evaluate 'let' and 'withinput' fields
			t_range_field__size = 8;
			}
			break;
		case 3:
			// Parse "range_field_3"
			{
			range_field_3_ = new Range_Field_3();
			range_field_3_->Parse((t_begin_of_data + 3), t_end_of_data);
			// Evaluate 'let' and 'withinput' fields
			t_range_field__size = 2;
			}
			break;
		case 4:
			// Parse "range_field_4"
			{
			range_field_4_ = new Range_Field_4();
			range_field_4_->Parse((t_begin_of_data + 3), t_end_of_data, t_byteorder);
			// Evaluate 'let' and 'withinput' fields
			t_range_field__size = 4;
			}
			break;
		case 5:
			// Parse "range_field_5"
			{
			range_field_5_ = new Range_Field_5();
			range_field_5_->Parse((t_begin_of_data + 3), t_end_of_data, t_byteorder);
			// Evaluate 'let' and 'withinput' fields
			t_range_field__size = 8;
			}
			break;
		case 6:
			// Parse "range_field_6"
			{
			// Evaluate 'let' and 'withinput' fields
			t_range_field__size = 0;
			}
			break;
		case 7:
			// Parse "range_field_7"
			{
			range_field_7_ = new Range_Field_7();
			range_field_7_->Parse((t_begin_of_data + 3), t_end_of_data);
			// Evaluate 'let' and 'withinput' fields
			t_range_field__size = 1;
			}
			break;
		case 8:
			// Parse "range_field_8"
			{
			range_field_8_ = new Range_Field_8();
			range_field_8_->Parse((t_begin_of_data + 3), t_end_of_data, t_byteorder);
			// Evaluate 'let' and 'withinput' fields
			t_range_field__size = 2;
			}
			break;
		case 9:
			// Parse "range_field_9"
			{
			range_field_9_ = new Range_Field_9();
			range_field_9_->Parse((t_begin_of_data + 3), t_end_of_data, t_byteorder);
			// Evaluate 'let' and 'withinput' fields
			t_range_field__size = 4;
			}
			break;
		case 11:
			// Parse "range_field_b"
			{
			range_field_b_ = new Range_Field_B();
			range_field_b_->Parse((t_begin_of_data + 3), t_end_of_data);
			// Evaluate 'let' and 'withinput' fields
			t_range_field__size = 1;
			}
			break;
		default:
			// Parse "unknown"
			{
			int t_unknown_string_length;
			t_unknown_string_length = (t_end_of_data) - ((t_begin_of_data + 3));
			int t_unknown__size;
			t_unknown__size = t_unknown_string_length;
			// check for negative sizes
			if ( t_unknown_string_length < 0 )
			throw ExceptionInvalidStringLength("./dnp3-protocol.pac:74", t_unknown_string_length);
			unknown_.init((t_begin_of_data + 3), t_unknown_string_length);
			// Evaluate 'let' and 'withinput' fields
			t_range_field__size = t_unknown__size;
			}
			break;
		}
	// Evaluate 'let' and 'withinput' fields
	
	int t_Object_Header__size;
	const_byteptr const t_dataptr_after_range_field = (t_begin_of_data + 3) + (t_range_field__size);
	BINPAC_ASSERT(t_dataptr_after_range_field <= t_end_of_data);
	t_Object_Header__size = t_dataptr_after_range_field - t_begin_of_data;
	// Evaluate 'let' and 'withinput' fields
	BINPAC_ASSERT(t_begin_of_data + (t_Object_Header__size) <= t_end_of_data);
	return t_Object_Header__size;
	}

Range_Field_0::Range_Field_0()
	{
	start_index_ = 0;
	stop_index_ = 0;
	}

Range_Field_0::~Range_Field_0()
	{
	}

int Range_Field_0::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data)
	{
	// Checking out-of-bound for "Range_Field_0"
	if ( t_begin_of_data + (2) > t_end_of_data )
		{
		// Handle out-of-bound condition
		throw ExceptionOutOfBound("Range_Field_0",
			(0) + (2), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "start_index"
	start_index_ = *((uint8 const *) (t_begin_of_data));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "stop_index"
	stop_index_ = *((uint8 const *) ((t_begin_of_data + 1)));
	// Evaluate 'let' and 'withinput' fields
	
	// Evaluate 'let' and 'withinput' fields
	BINPAC_ASSERT(t_begin_of_data + (2) <= t_end_of_data);
	return 2;
	}

Range_Field_1::Range_Field_1()
	{
	start_index_ = 0;
	stop_index_ = 0;
	}

Range_Field_1::~Range_Field_1()
	{
	}

int Range_Field_1::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, int t_byteorder)
	{
	// Checking out-of-bound for "Range_Field_1"
	if ( t_begin_of_data + (4) > t_end_of_data )
		{
		// Handle out-of-bound condition
		throw ExceptionOutOfBound("Range_Field_1",
			(0) + (4), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "start_index"
	start_index_ = FixByteOrder(t_byteorder, *((uint16 const *) (t_begin_of_data)));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "stop_index"
	stop_index_ = FixByteOrder(t_byteorder, *((uint16 const *) ((t_begin_of_data + 2))));
	// Evaluate 'let' and 'withinput' fields
	
	// Evaluate 'let' and 'withinput' fields
	BINPAC_ASSERT(t_begin_of_data + (4) <= t_end_of_data);
	return 4;
	}

Range_Field_2::Range_Field_2()
	{
	start_index_ = 0;
	stop_index_ = 0;
	}

Range_Field_2::~Range_Field_2()
	{
	}

int Range_Field_2::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, int t_byteorder)
	{
	// Checking out-of-bound for "Range_Field_2"
	if ( t_begin_of_data + (8) > t_end_of_data )
		{
		// Handle out-of-bound condition
		throw ExceptionOutOfBound("Range_Field_2",
			(0) + (8), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "start_index"
	start_index_ = FixByteOrder(t_byteorder, *((uint32 const *) (t_begin_of_data)));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "stop_index"
	stop_index_ = FixByteOrder(t_byteorder, *((uint32 const *) ((t_begin_of_data + 4))));
	// Evaluate 'let' and 'withinput' fields
	
	// Evaluate 'let' and 'withinput' fields
	BINPAC_ASSERT(t_begin_of_data + (8) <= t_end_of_data);
	return 8;
	}

Range_Field_3::Range_Field_3()
	{
	start_addr_ = 0;
	stop_addr_ = 0;
	}

Range_Field_3::~Range_Field_3()
	{
	}

int Range_Field_3::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data)
	{
	// Checking out-of-bound for "Range_Field_3"
	if ( t_begin_of_data + (2) > t_end_of_data )
		{
		// Handle out-of-bound condition
		throw ExceptionOutOfBound("Range_Field_3",
			(0) + (2), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "start_addr"
	start_addr_ = *((uint8 const *) (t_begin_of_data));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "stop_addr"
	stop_addr_ = *((uint8 const *) ((t_begin_of_data + 1)));
	// Evaluate 'let' and 'withinput' fields
	
	// Evaluate 'let' and 'withinput' fields
	BINPAC_ASSERT(t_begin_of_data + (2) <= t_end_of_data);
	return 2;
	}

Range_Field_4::Range_Field_4()
	{
	start_addr_ = 0;
	stop_addr_ = 0;
	}

Range_Field_4::~Range_Field_4()
	{
	}

int Range_Field_4::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, int t_byteorder)
	{
	// Checking out-of-bound for "Range_Field_4"
	if ( t_begin_of_data + (4) > t_end_of_data )
		{
		// Handle out-of-bound condition
		throw ExceptionOutOfBound("Range_Field_4",
			(0) + (4), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "start_addr"
	start_addr_ = FixByteOrder(t_byteorder, *((uint16 const *) (t_begin_of_data)));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "stop_addr"
	stop_addr_ = FixByteOrder(t_byteorder, *((uint16 const *) ((t_begin_of_data + 2))));
	// Evaluate 'let' and 'withinput' fields
	
	// Evaluate 'let' and 'withinput' fields
	BINPAC_ASSERT(t_begin_of_data + (4) <= t_end_of_data);
	return 4;
	}

Range_Field_5::Range_Field_5()
	{
	start_addr_ = 0;
	stop_addr_ = 0;
	}

Range_Field_5::~Range_Field_5()
	{
	}

int Range_Field_5::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, int t_byteorder)
	{
	// Checking out-of-bound for "Range_Field_5"
	if ( t_begin_of_data + (8) > t_end_of_data )
		{
		// Handle out-of-bound condition
		throw ExceptionOutOfBound("Range_Field_5",
			(0) + (8), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "start_addr"
	start_addr_ = FixByteOrder(t_byteorder, *((uint32 const *) (t_begin_of_data)));
	// Evaluate 'let' and 'withinput' fields
	
	// Parse "stop_addr"
	stop_addr_ = FixByteOrder(t_byteorder, *((uint32 const *) ((t_begin_of_data + 4))));
	// Evaluate 'let' and 'withinput' fields
	
	// Evaluate 'let' and 'withinput' fields
	BINPAC_ASSERT(t_begin_of_data + (8) <= t_end_of_data);
	return 8;
	}

Range_Field_7::Range_Field_7()
	{
	object_count_ = 0;
	}

Range_Field_7::~Range_Field_7()
	{
	}

int Range_Field_7::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data)
	{
	// Checking out-of-bound for "Range_Field_7"
	if ( t_begin_of_data + (1) > t_end_of_data )
		{
		// Handle out-of-bound condition
		throw ExceptionOutOfBound("Range_Field_7",
			(0) + (1), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "object_count"
	object_count_ = *((uint8 const *) (t_begin_of_data));
	// Evaluate 'let' and 'withinput' fields
	
	// Evaluate 'let' and 'withinput' fields
	BINPAC_ASSERT(t_begin_of_data + (1) <= t_end_of_data);
	return 1;
	}

Range_Field_8::Range_Field_8()
	{
	object_count_ = 0;
	}

Range_Field_8::~Range_Field_8()
	{
	}

int Range_Field_8::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, int t_byteorder)
	{
	// Checking out-of-bound for "Range_Field_8"
	if ( t_begin_of_data + (2) > t_end_of_data )
		{
		// Handle out-of-bound condition
		throw ExceptionOutOfBound("Range_Field_8",
			(0) + (2), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "object_count"
	object_count_ = FixByteOrder(t_byteorder, *((uint16 const *) (t_begin_of_data)));
	// Evaluate 'let' and 'withinput' fields
	
	// Evaluate 'let' and 'withinput' fields
	BINPAC_ASSERT(t_begin_of_data + (2) <= t_end_of_data);
	return 2;
	}

Range_Field_9::Range_Field_9()
	{
	object_count_ = 0;
	}

Range_Field_9::~Range_Field_9()
	{
	}

int Range_Field_9::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, int t_byteorder)
	{
	// Checking out-of-bound for "Range_Field_9"
	if ( t_begin_of_data + (4) > t_end_of_data )
		{
		// Handle out-of-bound condition
		throw ExceptionOutOfBound("Range_Field_9",
			(0) + (4), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "object_count"
	object_count_ = FixByteOrder(t_byteorder, *((uint32 const *) (t_begin_of_data)));
	// Evaluate 'let' and 'withinput' fields
	
	// Evaluate 'let' and 'withinput' fields
	BINPAC_ASSERT(t_begin_of_data + (4) <= t_end_of_data);
	return 4;
	}

Range_Field_B::Range_Field_B()
	{
	object_count_ = 0;
	}

Range_Field_B::~Range_Field_B()
	{
	}

int Range_Field_B::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data)
	{
	// Checking out-of-bound for "Range_Field_B"
	if ( t_begin_of_data + (1) > t_end_of_data )
		{
		// Handle out-of-bound condition
		throw ExceptionOutOfBound("Range_Field_B",
			(0) + (1), 
			(t_end_of_data) - (t_begin_of_data));
		}
	// Parse "object_count"
	object_count_ = *((uint8 const *) (t_begin_of_data));
	// Evaluate 'let' and 'withinput' fields
	
	// Evaluate 'let' and 'withinput' fields
	BINPAC_ASSERT(t_begin_of_data + (1) <= t_end_of_data);
	return 1;
	}

Object_With_Header::Object_With_Header()
	{
	object_header_ = 0;
	}

Object_With_Header::~Object_With_Header()
	{
	delete object_header_;
	object_header_ = 0;
	}

int Object_With_Header::Parse(const_byteptr const t_begin_of_data, const_byteptr const t_end_of_data, int t_byteorder)
	{
	// Parse "object_header"
	object_header_ = new Object_Header();
	int t_object_header__size;
	t_object_header__size = object_header_->Parse(t_begin_of_data, t_end_of_data, t_byteorder);
	// Evaluate 'let' and 'withinput' fields
	
	int t_Object_With_Header__size;
	const_byteptr const t_dataptr_after_object_header = t_begin_of_data + (t_object_header__size);
	BINPAC_ASSERT(t_dataptr_after_object_header <= t_end_of_data);
	t_Object_With_Header__size = t_dataptr_after_object_header - t_begin_of_data;
	// Evaluate 'let' and 'withinput' fields
	BINPAC_ASSERT(t_begin_of_data + (t_Object_With_Header__size) <= t_end_of_data);
	return t_Object_With_Header__size;
	}

Dnp3_Conn::Dnp3_Conn(BroAnalyzer const & bro_analyzer)
	{
	upflow_ = new Dnp3_Flow(this, true);
	downflow_ = new Dnp3_Flow(this, false);
	bro_analyzer_ = bro_analyzer;
	}

Dnp3_Conn::~Dnp3_Conn()
	{
	delete upflow_;
	upflow_ = 0;
	delete downflow_;
	downflow_ = 0;
	}

void Dnp3_Conn::NewData(bool is_orig, const_byteptr begin, const_byteptr end)
	{
	if ( is_orig )
		upflow_->NewData(begin, end);
	else
		downflow_->NewData(begin, end);
	}

void Dnp3_Conn::NewGap(bool is_orig, int gap_length)
	{
	if ( is_orig )
		upflow_->NewGap(gap_length);
	else
		downflow_->NewGap(gap_length);
	}

void Dnp3_Conn::FlowEOF(bool is_orig)
	{
	if ( is_orig )
		upflow_->FlowEOF();
	else
		downflow_->FlowEOF();
	}

Dnp3_Flow::Dnp3_Flow(Dnp3_Conn * connection, bool is_orig)
	{
	connection_ = connection;
	is_orig_ = is_orig;
	dataunit_ = 0;
	context_ = 0;
	}

Dnp3_Flow::~Dnp3_Flow()
	{
	delete dataunit_;
	dataunit_ = 0;
	delete context_;
	context_ = 0;
	}

void Dnp3_Flow::NewData(const_byteptr t_begin_of_data, const_byteptr t_end_of_data)
	{
	try
		{
		dataunit_ = new Dnp3_PDU(is_orig());
		context_ = new ContextDnp3(connection(), this);
		int t_dataunit__size;
		t_dataunit__size = dataunit_->Parse(t_begin_of_data, t_end_of_data);
		// Evaluate 'let' and 'withinput' fields
		delete dataunit_;
		dataunit_ = 0;
		delete context_;
		context_ = 0;
		}
	catch ( Exception const &e )
		{
		delete dataunit_;
		dataunit_ = 0;
		delete context_;
		context_ = 0;
		throw e;
		}
	}

void Dnp3_Flow::NewGap(int gap_length)
	{
	}
void Dnp3_Flow::FlowEOF()
	{
	}
bool Dnp3_Flow::deliver_message(uint16 length)
	{

		if ( ::sample_message )
			{
			BifEvent::generate_sample_message(
				connection()->bro_analyzer(),
				connection()->bro_analyzer()->Conn(),
				is_orig(), length);
			}

		return true;
		
	}

} // namespace Dnp3
}  // namespace binpac
